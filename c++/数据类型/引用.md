# 引用

C++中的引用是对另一个变量的别名，它允许你以另一个名字来引用同一个变量。引用在C++中是非常强大的特性，用于多种用途，包括函数参数传递、返回值优化、以及提供更直观和安全的内存访问方式。

## 引用的声明与初始化

引用必须在声明时被初始化，并且一旦初始化后，就不能改变引用的关联对象。声明引用的基本语法是：

```cpp
type &reference_name = variable;

类型& 引用变量名(对象名) = 引用实体；
```

这里，`type`是引用类型，`reference_name`是引用的名称，`variable`是要引用的变量。例如：

```cpp
int x = 10;
int &ref = x; // ref 是 x 的引用
```

## 引用的特性

💦 引用在定义时必须初始化

💦 一个变量可以有多个引用

💦 一个引用可以绑定其他引用

💦 引用一旦绑定一个对象，再不能绑定其他对象

💦 引用可以绑定任何类型(对象)，如变量、指针、对象。

## 引用的底层实现

- 引用的底层实现是指针常量(常指针)，即绑定对象不可改变的指针。
  - 引用本身自带const顶层修饰

编译器层面对于引用更多地表现为一个`重定向操作`。

## 常引用

const引用，就是无法使用该别名修改原对象的值。

- 对比引用本质的理解，常引用的本质就是，指向常量的常量指针，即既不能修改绑定对象的值，也不能重新再绑定新对象的指针。
  - const修饰引用，是底层修饰

使用场景：

1. 给常量取别名`const int& c = 20;`
   - 临时变量具有常性
2. 对权限控制的用处
   1. 如若函数写出普通的引用，那么很多参数可能会传不过来，如临时变量。

## 引用与指针的区别

尽管引用和指针在某些方面表现相似，但它们之间有根本的区别：

1. 概念：引用概念上定义一个变量的别名，指针存储一个变量地址
2. 初始化：引用必须在定义时初始化，而指针可以在任何时候被初始化。
3. 空值：引用必须连接到合法的存储位置，不能为NULL或未定义；指针可以指向NULL。
4. 操作符：对引用的操作如同直接操作变量本身，不需要解引用操作（如*）；而指针需要解引用才能访问目标变量。
5. 修改：一旦定义，引用就不能被重新绑定到另一个变量；指针可以改变指向。
6. 内存占用：引用本身不占用额外的内存空间，它只是目标变量的别名；指针本身占用内存空间（通常为4或8字节）。
7. `++`：引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小
8. 有多级指针，但是没有多级引用
9. 访问实体方式不同，指针需要显式解引用，引用编译器自己处理
10. 引用比指针使用起来相对更安全
11. const引用：C++中可以有const引用，它不允许修改引用的对象，但可以引用const或非const对象；指针也有const指针，可以指向const或非const对象，但const指针自身是否可变是另外一回事。

## 引用的用途

- 函数参数：使用引用作为函数参数可以避免复制大对象的成本，并且允许函数直接修改外部变量。
  - 交换两数：传值无法交换，使用引用和指针都可以实现
  - 单链表的头节点修改，以往需要二级指针，现在可以使用引用实现。
- 函数返回值：返回引用可以避免复制，特别是当返回容器或大对象时非常有用，但需谨慎以避免返回局部变量的引用导致的未定义行为。
  - 传值返回：当需要将函数中的临时变量返回时，无论这个变量是在栈区、堆区或者静态区开辟空间，都会通过一个临时变量去充当返回值【小一点的话可能是寄存器eax，大一点可能是在上一层栈帧开好的】然后再返回给外界的值做接受。
  - 传引用返回(优化):对于像`静态变量`、`全局变量`等这些出了作用域不会销毁的对象，就可以使用【传引用返回】
- 别名：为复杂的表达式或对象提供简洁的访问方式。
- 迭代器：C++标准库中的迭代器常使用引用，使得可以像直接操作容器元素那样操作迭代器指向的元素。

## 注意事项

- const与非const引用：非const引用只能绑定到同类型的非const对象，而const引用可以绑定到const或非const对象，甚至可以绑定到临时对象，这有助于实现诸如const char&的字符串字面量传递。
- 避免悬空引用：确保引用的生命周期不长于它所引用的对象，否则会导致未定义行为。
