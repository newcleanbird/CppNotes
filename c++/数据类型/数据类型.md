# 数据类型

## 声明 定义 初始化
- 声明是关于存在性的宣告，告诉编译器期待什么类型的标识符。
- 定义是实际创建变量或对象并分配内存的过程，通常伴随着初始化。
- 初始化是为变量或对象赋予初始状态的操作，可以在定义时一并完成。

### 声明（Declaration）
声明定义：是指告诉编译器变量的名称、类型以及可能的其他属性（如常量性、引用性等），但不一定分配内存或赋予初始值。

- 声明用于告诉编译器变量的**名称 和 类型，一般不分配内存**。这样就可以在之后的代码中使用它们。
- 变量的声明有两重含义:
  - 告诉编译器，这个名字已经匹配到一块内存上，下面的代码用到变量或者对象是在别的地方定义的。声明可以出现多次。
  - 告诉编译器，这个名字已经被预定了，别的地方再也不能用它来作为变量名或对象名。
- 声明可以出现在多个地方，但变量只应被定义一次。

示例：
```cpp
int age; // 声明了一个名为age的整形变量

extern int var; // 声明已经在其他地方有定义了，提示编译器遇到此变量时在其它模块中寻找其定义。
extern int ble = 10; // 表示定义了变量 ble，即使是 extern ，如果给变量赋值了，就是定义了。
typedef int INT; // 声明
struct Node;    // 声明
```

#### 声明的类型
1. 变量声明：
- 基本变量声明：例如 int num; 告诉编译器有一个名为num的整型变量存在。
- 指针、引用、数组等复合类型的声明：如 int* ptr;（指针）、int& ref = num;（引用）、int arr[10];（数组）。
- const 和 volatile限定符的使用：如 const int cNum = 10;（常量）、volatile int vNum;（易变变量）。
- 外部变量声明（使用extern）：extern int extVar; 表示变量extVar在别处定义。

2. 函数声明：
- 函数原型：如 int add(int a, int b); 告知编译器函数add接受两个整数参数并返回一个整数。
- 默认参数、重载函数的声明：函数可以通过不同参数列表或默认参数值来重载。
- inline函数和constexpr函数的声明：用于内联展开或编译时计算。

3. 类和结构体声明：
- 类定义本身就是一种声明，同时定义了数据成员和成员函数：class MyClass { ... };
- 前向声明：如 class ForwardDeclared; 仅声明类的存在，未给出细节，便于解决循环依赖问题。

4. 枚举声明：enum Color { Red, Green, Blue }; 定义了一个枚举类型Color。

5. 模板声明：template<typename T> T max(T a, T b); 声明了一个泛型最大值函数模板。

6. 命名空间声明：namespace MyNamespace { ... } 用于组织相关的类型、对象和函数。

7. 类型别名声明：typedef 或 using，如 typedef int Integer; 或 using Integer = int; 创建类型别名。

8. extern "C"声明：用于指示C++编译器按照C语言的链接规则处理函数或变量，如 extern "C" void func();。

9. 友元声明：在类定义中使用 friend 关键字声明其他类或函数为该类的友元，允许访问私有和保护成员。

10. using声明：在命名空间作用域或类作用域内，使用 using 引入特定名称，如 using std::cout;。


### 定义（Definition）

变量的定义用于为变量**分配存储空间，并可选地给出初始值，为变量指定初始值。**对于非静态局部变量和全局变量，定义也会执行初始化。

- 在一个程序中，变量**有且仅有一个定义**。

- 在 C/C++ 中，变量的声明和定义区别并不大，定义和声明往往是同时发生，变量定义时，会根据变量类型分配空间，

```c++
int age = 25; // 定义了一个名为age的整型变量，并初始化为25

int add(int x, int y) { return x + y; } // 函数的定义
```

#### 注意
- **不应该在头文件中定义变量**，因为一个头文件可能会被一个程序的许多源文件所包含。
- **全局变量或静态变量初始值为0**，**局部变量初始化为随机值**。

### 初始化（Initialization）
初始化是为变量赋予其初始值的过程。初始化可以在定义时进行，也可以在后续的代码中通过赋值操作完成，尽管某些情况下（如静态局部变量、全局变量、类的成员变量）编译器会自动执行默认初始化。

示例：
```cpp
int age = 30; // 初始化age变量为30
```
对于类的对象，初始化可能涉及到构造函数的调用：
```cpp
Person person("Alice", 30); // 初始化Person对象，通过构造函数传入初始值
```

### 变量声明和定义的区别

- 变量在使用前就要被定义或者声明。
- 一个变量可以在多个地方声明，但是只能在一个地方定义；(多声明，单定义)
- 变量的定义分配地址和存储空间，变量的声明不分配地址；
- 通常变量的定义和声明是同时发生的，注意：extern 变量类型 变量名 仅是声明。
- 很多时候一个变量只是声明不分配内存空间，直到具体使用时才初始化，分配内存空间，如外部变量；

```c++
#include<bits/stdc++.h>
using namespace std;

extern int fun();    // 声明
int fun(){}  // 定义

int main()
{
    extern int A; // 声明A是一个外部已经定义了的外部变量
    // 声明外部变量时可以把类型去掉：extern A;
    extern int B = 100; // 定义，即使是extern
}
int A; // 是定义，定义了A是一个整型的全局变量(外部变量)
```

### 全局变量重定义问题

#### 原因

1. 外部链接性
   首先明确一点全局变量是具备 外部链接性的，何为外部连接性呢？外部链接性的变量通常简称为外部变量，作用域为整个文件。可以在文件中位于外部变量定义的后面的任意函数中使用它，因此也称为全局变量。
2. 头文件的作用
   当.c或者.cpp引用头文件的时候，无非是将头文件的内容拷贝入本.c或者.cpp。当我们在头文件中定义一个全局变量，而又在多个.c或者.cpp文件中引用它，就会引发全局变量重定义。话不多说看图：本图中B.cpp和C.cpp都引用了a.h等价于在B.cpp和C.cpp中都声明了全局变量。而全局变量的作用域是整个文件，故而出现了全局变量重定义的问题。

```c++
a.h
int A; // 定义全局变量

B.cpp
#include<a.h>
{
    a = 200;

}
C.cpp
#include<a.h>
{
    b = 150;
}
```

#### 解决办法

1. 可以引入 static 关键字，这个关键字的作用就是
   1. 全局变量范围只能限定在文件里，不会外联到整个模块和项目中。
   2. 变量只在源文件中有效。

> 尽量使用static关键字把变量定义限制于该源文件作用域，除非变量被设计成全局的。

2. 引入 inline关键字修饰函数
   inline 相当于在函数定义的地方，将函数展开，这样就可以避免函数符号在符号表中被多次找到。
3. 永远不要在.h文件中定义变量,这样容易导致重复定义错误。
4. 可以在头文件中声明一个变量，在用的时候包含这个头文件就声明了这个变量。
5. 头文件(.h)中 是对于该模块接口的声明，接口包括该模块提供给其它模块调用的外部函数及外部全局变量，对这些变量和函数都需在.h中文件中冠以extern关键字声明。

## 数据类型
1. 基本数据类型（Primitive Data Types）
   - 整型（Integer Types）：short, int, long, long long，以及它们的无符号版本unsigned short, unsigned int, unsigned long, unsigned long long。C++11还引入了char16_t, char32_t用于宽字符支持。
   - 字符型（Character Types）：char，宽字符类型wchar_t。
   - 布尔型（Boolean Type）：bool，取值为true或false。
   - 浮点型（Floating Point Types）：float, double, long double。

2. 复合数据类型（Compound Data Types）
   - 数组（Arrays）：固定大小的相同类型元素集合。
   - 结构体（Structures）：用户自定义的复合数据类型，可以包含不同类型的数据成员。
   - 联合体（Unions）：共享同一块内存区域的不同类型成员，一次只能有效使用其中一个成员。
   - 枚举（Enums）：定义一组命名的整数常量。

3. 特殊数据类型
   - 空类型（Void Type）：void，通常用于表示没有类型或者函数不返回值。
   - 指针类型（Pointer Types）：存储内存地址的变量，如int*, char**等。
   - 函数指针：指向函数的指针，可以调用对应的函数。
   - 成员指针：指向类成员变量或成员函数的指针。
  
4. 高级数据类型（Advanced or User-Defined Types）
   - 类（Classes）：支持封装、继承、多态的复杂数据类型。
   - 模板类型（Template Types）：泛型编程的基础，允许类型参数化，如vector<int>, list<double>。
   - 智能指针（Smart Pointers）：C++11引入，如unique_ptr, shared_ptr, 提供自动内存管理。
   - 类型别名（Type Aliases）：使用typedef或using关键字为现有类型定义新名称。
   - 枚举类（Enum Classes）：C++11引入，提供了更好的类型安全和作用域控制的枚举。



### 基本数据类型(Primitive Data Types)

#### 整形(Integral Types)
- short: 通常占用2字节，用于存储较小的整数值。
- int: 通常占用4字节，在大多数平台上是最常用的整数类型。
- long: 在32位系统上通常也是4字节，但64位系统上可能是8字节，具体取决于编译器。
- long long: 至少占用8字节，用于存储大整数。
- 以上每种整型都有对应的无符号（unsigned）版本，如unsigned int，能够存储两倍的正数范围，但不包括负数。

#### 字符型(Character Types)
- char: 通常占用1字节，用于存储单个字符，可以是ASCII码。
- wchar_t: 宽字符类型，用于存储更广泛的字符集，如Unicode字符，其大小依赖于实现。
- char16_t, char32_t: C++11引入，分别用于存储UTF-16和UTF-32编码的字符。

#### 浮点型(Floating Point Types)
- float: 单精度浮点数，通常占用4字节，适合不需要很高精度的浮点计算。
- double: 双精度浮点数，通常占用8字节，提供更高的精度，是默认的浮点类型。
- long double: 提供的精度至少与double相同，但具体大小和精度依编译器而定。

#### 布尔型(Boolean Type)
- bool: 只有两个可能的值：true和false，通常占用1字节，但具体实现可能有所不同。

#### 空类型(Void Type)
- void: 不代表任何特定类型，通常用于表示没有返回值的函数或泛型指针。

### 复合数据类型(Compound Types)
C++中的复合数据类型（Compound Types）是基于基本数据类型构建的，允许组合和操作多个数据项，从而形成更复杂的数据结构。复合数据类型使得程序能够处理现实世界中更为复杂的数据模型，提高代码的组织性和可读性。

#### 数组（Arrays）：
数组是一系列相同类型元素的集合，这些元素在内存中连续存储。数组的声明需要指定元素类型和数组大小。例如，int numbers[5]声明了一个可以存储5个整数的数组。

#### 字符串（String）：
C++处理字符串有两种方式：C风格字符串（字符数组以空字符\0结尾）和std::string类。std::string是C++标准库提供的一个类，提供了丰富的字符串操作方法，使用前需包含<string>头文件。

#### 指针（Pointer）：
指针是一种特殊的变量，存储的是另一个变量的内存地址。通过指针，可以间接访问和修改内存中的数据。指针类型定义时需指定其指向的变量类型，如int *ptrToInt。

#### 结构体（Structure）：
结构体是一种复合数据类型，允许你定义自己的数据类型，组合不同基本类型或复合类型的成员。例如，struct Person {std::string name; int age;}定义了一个包含姓名和年龄的结构体类型。

#### 联合体（Union）：
联合体也是一种复合类型，但它所有的成员共享同一块内存区域。任何时候，联合体中只有一个成员的值是有效的。这在需要节省内存或实现类型转换的场景中很有用。

#### 枚举（Enumeration）：
枚举类型允许定义一系列命名的常量，这些常量代表整数值。例如，enum Color {Red, Green, Blue};定义了一个颜色枚举，其中Red、Green、Blue分别对应整数值0、1、2。

#### 类（Class）：
类是C++面向对象编程的核心，它不仅包含了数据成员（变量），还包含了成员函数（方法），支持封装、继承和多态等特性。类的定义允许创建用户自定义的复合类型，用于构建复杂的对象模型。

#### 模板（Template）：
模板不是直接的数据类型，但它们允许创建泛型代码，可以处理多种数据类型。模板允许你定义函数或类，在实例化时才指定具体的数据类型，提供了极大的灵活性和代码复用性。

### 特殊数据类型
#### void类型:
- void类型是一个独一无二的数据类型，它不代表任何具体的数据值。它主要用于函数返回类型，表明该函数不返回任何值。同时，void*是一种指针类型，可以指向任何类型的数据，但使用时需要强制类型转换来明确目标类型，以确保安全。

#### nullptr（空指针常量）:
- 自C++11起，nullptr被引入作为一种特殊类型的字面量，用于表示空指针。它比传统的NULL宏更安全，因为它有自己的类型std::nullptr_t，可以避免类型转换时的歧义，减少潜在的错误。

#### auto类型推导:
- 虽然auto不是一个数据类型本身，但它是一种类型说明符，能够让编译器自动推导出变量的类型。这在处理复杂类型或者避免冗余时非常有用，比如在使用迭代器或返回类型复杂的表达式时。

#### decltype类型推导:
- decltype关键字用于获取一个表达式的类型。它不是直接定义变量的类型，而是帮助获取并使用其它地方已存在的类型，常用于泛型编程和模板元编程中。

#### 类型别名（typedef和using）:
- typedef和C++11引入的using关键字允许为现有的类型创建一个新的名字，即类型别名。这对于简化复杂类型名、提高代码可读性及创建平台无关的类型定义非常有帮助。

#### 枚举类（enum class）:
- 从C++11开始，枚举类（enum class）提供了一种更安全、具有更好类型安全性的枚举类型。与传统枚举相比，枚举类的成员默认具有私有作用域，减少了命名冲突的风险。

#### 类型特征（type traits）:
- 标准模板库(STL)中的类型特征是一组模板，用于检查或修改类型属性。例如，std::is_integral<T>可以检查类型T是否为整数类型，这类特征广泛应用于泛型编程中，以实现条件编译和类型安全的代码。

### 高级数据类型(Advanced or User-Defined Types)
#### 类（Class）:
类是C++面向对象编程的核心，允许用户定义自己的数据类型。类可以包含数据成员（变量）和成员函数（方法），支持封装、继承和多态等面向对象的特性。类的使用可以更好地模拟现实世界的实体和行为，提升代码的组织性和重用性。

#### 枚举类（Enum Class 或 Enum Struct）:
从C++11开始，枚举类（enum class 或 enum struct）提供了一种更安全的枚举类型，其成员默认具有限定作用域，减少了命名空间污染。枚举类提高了类型安全性，因为每个枚举值都有其所属的枚举类型作为上下文。

#### 模板（Template）:
模板是C++泛型编程的关键特性，允许程序员编写独立于类型的代码。模板可以用来创建函数模板和类模板，使得代码能够适用于多种数据类型，提高了代码的通用性和灵活性。例如，std::vector<T>就是一个典型的类模板，可以创建容纳任意类型的动态数组。

#### 智能指针（Smart Pointers）:
智能指针是C++标准库提供的高级指针类型，如std::unique_ptr、std::shared_ptr和std::weak_ptr，它们自动管理内存，防止内存泄漏和悬挂指针问题。智能指针通过封装原始指针，提供了所有权管理和自动销毁机制。

#### STL容器（Standard Template Library Containers）:
STL容器如std::vector、std::list、std::map等，是预定义的数据结构，提供了高效的内存管理和数据访问接口。它们是模板类，可以存储任意类型的数据，并且内置了迭代器、算法等支持，极大地简化了常见的数据结构操作。

#### 联合（Union）:
虽然联合属于基本数据类型范畴，但其在高级编程中的用途使其值得一提。联合允许在相同的内存位置存储不同类型的变量，但一次只能有效使用其中一个成员。这在需要节省空间或实现类型转换时很有用，不过使用时需要注意数据一致性问题。

#### 类型别名（Type Alias）:
使用using或传统的typedef关键字定义类型别名，可以为复杂类型或频繁使用的类型提供简短易记的名字，提高代码的可读性和维护性。在现代C++中，using语法更加灵活，支持模板参数和更复杂的类型定义。

### 其他新类型
#### initializer_list
- initializer_list是一个标准库类型，是一个代表数组的轻量级包装器，用于存储同一类型的常量对象的列表。主要用于方便地初始化聚合类型（如数组、向量）和在构造函数中接受不定数量的同类型参数。支持作为函数参数或类成员初始化列表使用，用于传递一个初始化元素列表。
[initializer_list](../数据类型/initializer_list.md)

## 强制类型转换
[强制类型转换](../数据类型/强制类型转换.md)

## 列表初始化
列表初始化是一种 C++11 中引入的新特性，可用来初始化各种类型的对象，包括数组、结构体、类以及容器等。具体来说，列表初始化使用花括号 {} 将一组值括起来，用逗号分隔各个元素，形成一个初始化列表；

[列表初始化](../数据类型/列表初始化.md)