# 移动语义 与 move函数

## 移动语义
移动语义（Move Semantics）是C++11引入的一项重要特性，旨在优化资源管理，特别是对于那些拥有动态分配内存或大型数据结构的对象。移动语义通过所谓的“移动构造函数”（move constructor）和“移动赋值运算符”（move assignment operator）来避免不必要的深拷贝，从而提高程序的性能。下面是移动语义的详细解释：

### 基本概念
- 右值引用：右值引用（rvalue reference）是移动语义的基础，它由两个与符号（&&）表示，如 T&&。右值引用可以绑定到临时对象或即将被销毁的对象（称为右值），这使得可以安全地“偷取”或“移动”这些对象的资源，而无需复制。
[左值和右值](../语言特性相关/左值和右值.md)

- 移动构造函数：当一个临时对象或将要被丢弃的对象被用于创建新对象时，移动构造函数会被调用。它将资源（如内存指针）从临时对象直接转移到新对象，同时将临时对象置为有效的但无害的状态（例如，清空指针）。移动构造函数的声明形式通常为 ClassName(ClassName&& other)。
[移动构造函数](../面向对象/类与对象.md/#移动构造函数)

- 移动赋值运算符：当一个对象通过赋值操作符 = 接收一个右值时，移动赋值运算符被调用，执行类似移动构造函数的操作，将资源从右值对象移动到左侧对象，并清理右侧对象。移动赋值运算符的声明形式为 ClassName& operator=(ClassName&& other)。
[移动赋值运算符](../面向对象/类与对象.md/#移动赋值运算符)

### 为什么需要移动语义
- 性能优化：对于含有动态分配内存或大量数据的类（如 std::vector、std::string），传统的深拷贝（复制构造函数和赋值运算符）可能非常昂贵。移动语义通过转移资源而非复制，大大减少了这类操作的成本。

- 资源管理：移动语义有助于避免资源泄露和不必要的资源复制，提高程序的内存效率和响应速度。

### 如何使用移动语义
- 自动应用：C++编译器在适当的情况下会自动选择移动构造函数或移动赋值运算符，例如，当临时对象被用作函数参数或返回值时。

- 手动实现：开发者可以显式地定义自己的移动构造函数和移动赋值运算符，以优化特定类的移动行为。这通常涉及到交换资源指针和清空源对象的资源。

### 注意事项
- 资源所有权：移动操作后，源对象（被移动的对象）应处于有效的但无害的状态，通常意味着它不再拥有任何资源，任何对它的后续使用都应该是安全的，尽管可能没有实际意义。

- 与拷贝语义的区分：移动语义并不总是优于拷贝语义，二者有各自的应用场景。例如，当对象需要保持其状态的副本时，应使用拷贝而非移动。

- 避免误用：误用 std::move 可能导致意料之外的结果，特别是当对象被多次移动或源对象在移动后被继续使用时。

## move函数
### 功能和用途
1. 资源转移而非复制：在C++中，当对象被复制时，通常会执行深拷贝，这可能导致性能开销，特别是对于大型对象或包含动态分配内存的对象。通过使用移动语义，可以避免这种开销，将资源的所有权直接从一个对象转移到另一个对象，而不是复制资源。

2. 转换左值为右值引用：std::move 的核心作用是将一个左值表达式转换为一个右值引用类型。这使得原本只能绑定到临时对象（右值）的移动构造函数或移动赋值运算符能够被调用，从而实现资源的转移。

3. 使用时机：当确定一个对象不再需要其内部资源时（例如，对象即将被销毁或其资源将被替换），可以使用 std::move 将资源转移给另一个对象，以避免不必要的复制。

### 标准库 move() 函数
std::move是C++标准库中的一个 utility 函数，位于<utility>头文件中。它的主要作用是将一个左值（即便是一个非临时对象）转换为右值引用，从而暗示编译器这个对象可以被“移动”而不是被复制。这在处理大型对象或者资源拥有对象时特别有用，因为它允许实现更高效的资源转移，避免不必要的深拷贝操作。

#### 例子
```cpp
std::string str1("Hello, World!");
std::string str2 = std::move(str1); // 使用move，str1的资源可能会被转移到str2，str1可能被置为空或处于未定义状态
```
在这个例子中，str1的内容没有被复制到str2，而是str1内部的资源（如内存缓冲区）被转移给了str2，这样可以更快并且避免了额外的内存分配。请注意，调用std::move后，源对象（在这里是str1）的状态通常是未指定的（除非特别处理），因此通常认为它已经被“移动出去”，不应再被使用。

std::move 可以将一个左值强制转化为右值，继而可以通过右值引用使用该值，以用于移动语义。
```cpp
#include <iostream>
using namespace std;

void fun1(int& tmp)
{
	cout << "fun1(int& tmp):" << tmp << endl;
}

void fun2(int&& tmp)
{
	cout << "fun2(int&& tmp)" << tmp << endl;
}

int main()
{
	int var = 11;
	// fun1(12); // error:非常量引用值必须为左值
	fun1(var);
	// fun2(var);// error:无法将右值绑定到左值
	fun2(move(var));	// 将左值转换为右值
	fun2(1);	// 正常调用右值
}
```

### std::move() 函数的实现原理
``std::move``的声明如下：
```cpp
template< class T >
typename std::remove_reference<T>::type&& move(T&& t) noexcept;
```
它接受一个universal reference（万能引用）作为参数，然后转换为对应类型的右值引用返回。实际上，std::move并不直接移动任何数据，而是创建了一个右值引用，这个引用可以被移动构造函数或移动赋值运算符用来执行实际的移动操作。

说明：引用折叠原理
- 右值传递给上述函数的形参 T&& 依然是右值，即 T&& && 相当于 T&&。
- 左值传递给上述函数的形参 T&& 依然是左值，即 T&& & 相当于 T&。

小结：通过引用折叠原理可以知道，move() 函数的形参既可以是左值也可以是右值。
### remove_reference 具体实现：
```cpp
//原始的，最通用的版本
template <typename T> struct remove_reference{
    typedef T type;  //定义 T 的类型别名为 type
};
 
//部分版本特例化，将用于左值引用和右值引用
template <class T> struct remove_reference<T&> //左值引用
{ typedef T type; }
 
template <class T> struct remove_reference<T&&> //右值引用
{ typedef T type; }   
  
//举例如下,下列定义的a、b、c三个变量都是int类型
int i;
remove_refrence<decltype(42)>::type a;             //使用原版本，
remove_refrence<decltype(i)>::type  b;             //左值引用特例版本
remove_refrence<decltype(std::move(i))>::type  b;  //右值引用特例版本 
```

举例：
```cpp
int var = 10; 

转化过程：
1. std::move(var) => std::move(int&& &) => 折叠后 std::move(int&)

2. 此时：T 的类型为 int&，typename remove_reference<T>::type 为 int，这里使用 remove_reference 的左值引用的特例化版本

3. 通过 static_cast 将 int& 强制转换为 int&&

整个std::move被实例化如下
string&& move(int& t) 
{
    return static_cast<int&&>(t); 
}
```

#### 总结std::move() 实现原理：
- 利用引用折叠原理将右值经过 T&& 传递类型保持不变还是右值，而左值经过 T&&变为普通的左值引用，以保证模板可以传递任意实参，且保持类型不变；
- 然后通过 remove_refrence 移除引用，得到具体的类型 T；
- 最后通过 static_cast<> 进行强制类型转换，返回 T&& 右值引用。

### 注意事项
- 对象状态：使用 std::move 后，原对象的状态可能变得不可预测，通常认为是“被移动后的”或“无效的”，不应再被访问或使用。
- 不保证移动操作：虽然 std::move 促使使用移动构造函数或移动赋值，但实际上是否发生移动取决于接收对象的实现。如果对象没有定义合适的移动构造函数或移动赋值运算符，编译器可能退回到拷贝操作。
- 不改变实参：std::move 不改变实参本身，它仅仅改变了实参的类型，使得实参可以被当作右值使用。


