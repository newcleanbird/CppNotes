# C++函数

函数是一组一起执行一个任务的语句。与C程序类似，每个 C++ 程序都至少有一个函数，即主函数 main()，通过函数，还可以把一个复杂任务分解成为若干个易于解决的小任务，充分体现结构化程序设计由粗到精，逐步细化的设计思想，即将任务合理划分为功能相对简单的若干子任务，分别进行设计调试，并通过某种机制将其连接成完整的程序，可以提高程序设计的效率。

## 函数基础

### 函数定义的基本结构

函数定义包括以下几个部分：

* 返回类型：函数完成后返回给调用者的值的类型。如果没有返回值，使用void关键字。
* 函数名：标识函数的名称，遵循C++的标识符命名规则。
* 参数列表：函数可以接受零个或多个参数，参数之间用逗号分隔。每个参数包括类型和名称。如果没有参数，使用空的圆括号()。
* 函数体：花括号{}包围的一段代码，实现了函数的具体功能。

语法示例:

```cpp
返回类型 函数名(参数类型 参数名, ...) {
    // 函数体
    // ...
    [return 返回值;] // 如果函数不是void类型，通常需要返回一个值
}
```

无参数无返回值的例子:

```cpp
void greet() {
    std::cout << "Hello, World!" << std::endl;
}
```

有参数有返回值的例子:

```cpp
int add(int a, int b) {
    return a + b;
}
```

### 参数传递方式

C++支持两种参数传递方式：

* 值传递：函数接收参数的一份副本，对副本的操作不会影响原变量。这是默认的方式。
* 引用传递：通过引用或指针传递参数，允许函数直接修改实参的值。引用传递在参数前加&，指针传递则传递变量的地址。

### 返回类型

* 基本类型：如int、double、char等。
* 用户自定义类型：包括结构体、类的对象、指针、引用等。
* void：表示函数不返回任何值。

### 函数命名规则

* 遵循C++标识符命名规范，即只能由字母、数字和下划线组成，不能以数字开头。
* 采用驼峰式命名或下划线分隔单词，以增强可读性，如calculateTotal或calculate_total。

### 函数重载

C++支持函数重载，即在同一作用域内可以有多个同名函数，只要它们的参数列表不同（类型、数量或顺序不同）或具有不同的模板参数列表。

### 内联函数

使用inline关键字声明的函数，提示编译器尝试将函数体直接插入每次调用该函数的地方，以减少函数调用的开销，但是否真正内联取决于编译器。

### 递归函数

函数可以调用自身，称为递归函数。使用递归时要确保有一个明确的结束条件，防止无限循环。

## 函数 函数指针 仿函数 Lambda表达式

* **所有能用函数指针的地方都可以直接使用函数本身，还可以使用仿函数，也也可以使用lambda**

1. 直接使用函数：
    在C++11及以后的版本中，由于函数重载解析和类型推导机制，很多时候可以直接使用函数名称而不需要显式转换为函数指针。编译器会自动处理类型匹配问题。

    ```cpp
    template<typename Func>
    void functionToCall(Func func);

    // 直接传递函数
    functionToCall(myFunction);
    ```

2. 函数指针：
    函数指针是最基础的形式，它指向一个函数的地址，使得可以通过指针间接调用函数。如果一个函数的签名与要求的回调函数类型匹配，可以直接传递该函数的地址。

    ```cpp
    void functionToCall(void (*funcPtr)(int));
    void myFunction(int x) { /*...*/ }

    // 调用时
    functionToCall(myFunction);
    ```

3. 仿函数（Function Objects，也称为Functors）：
    仿函数是重载了()操作符的类的实例，可以像普通函数那样被调用。它们比函数指针更灵活，因为它们可以携带状态。

    ```cpp
    struct MyFunctor {
        void operator()(int x) { /*...*/ }
    };

    // 使用仿函数
    MyFunctor functor;
    functionToCall(functor);
    ```

4. Lambda表达式：
    Lambda表达式是C++11引入的匿名函数对象，可以在代码中直接定义并创建临时的仿函数对象。它们非常适合用于定义简短的、即时的函数逻辑，并且可以捕获上下文中的变量。

    ```cpp
    // 使用lambda表达式
    functionToCall([](int x) { /*...*/ });
    ```

### 函数（Function）

* 定义：最基础的代码单元，用于执行特定任务。它有名字、返回类型、参数列表和函数体。
* 特点：直接调用，可被重载，易于理解和调试。
* 使用场景：当任务相对独立，且可能在多处被调用时。

### 函数指针（Function Pointer）

* 定义：一个指向函数入口地址的指针变量，可以用来存储或传递函数地址。
* 特点：允许将函数作为参数传递给其他函数，或者从函数中返回一个函数地址，增加了灵活性。
* 语法：返回类型 (*指针变量名)(参数类型列表);
* 使用场景：当需要动态决定调用哪个函数时，或在回调函数、排序算法中作为比较函数等。

### 3. 仿函数（Function Object，Functor）

* 定义：一个重载了()操作符的类的对象，使得这个对象可以像函数一样被调用。
* 特点：除了执行功能外，还可以携带状态，比普通函数更灵活。
* 使用场景：在STL算法中作为策略传递，比如自定义的比较操作。

### 4. Lambda表达式（Lambda Expression）

* 定义：匿名函数，可以在代码中直接定义和使用，常用于创建短小的、临时的功能性代码片段。
* 特点：
  * 可以捕获周围作用域的变量（值捕获、引用捕获）。
  * 直接编写在调用位置，减少代码分散。
  * 支持自动类型推导，简洁明了。
* 语法：`[捕获列表] (参数列表) -> 返回类型 { 函数体 };`
* 使用场景：配合算法、在并发编程中定义任务、事件处理等，任何需要短小、即时定义函数的地方。\

### 对比总结

* 可读性：函数 > Lambda表达式 > 仿函数 > 函数指针（通常情况下，因为函数直接命名，而Lambda和仿函数可能隐藏逻辑，函数指针最不易理解）
* 灵活性：Lambda表达式 & 仿函数 > 函数指针 > 函数（Lambda和仿函数可以携带状态，函数指针可以动态改变调用目标，而普通函数较为固定）
* 复杂度：函数指针 > 仿函数 > Lambda表达式 > 函数（函数指针使用较为繁琐，Lambda和仿函数提供了高级特性，普通函数最简单直接）
