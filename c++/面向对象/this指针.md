# this指针

## 定义：

this 是 C++ 中的一个关键字，也是一个 const 指针，它指向当前对象，通过它可以访问当前对象的所有成员。

> 所谓当前对象，是指正在使用的对象。例如对于stu.show();，stu 就是当前对象，this 就指向 stu。

- this 实际上是成员函数的一个隐式形参，本质上是成员函数的局部变量。在调用成员函数时将对象的地址作为实参传递给 this。不过 this 这个形参是隐式的，它并不出现在代码中，而是在编译阶段由编译器默默地将它添加到参数列表中。
- this指针只能在成员函数中使用，并且只有在通过对象调用成员函数时才给 this 赋值。
- 在全局函数、静态成员函数中都不能用this。
- this指针是类的指针，指向对象的首地址。
- this指针只有在成员函数中才有定义，且存储位置会因编译器不同有不同存储位置。

## 特点
- 隐含性：this指针不需要开发者显式定义或初始化，它会在每个非静态成员函数被调用时自动被编译器处理。

- 常量性：this指针是一个指向常量的指针，这意味着它所指向的对象不能通过this指针被修改。但是，对象的成员可以通过this指针被修改，因为成员不是常量。

- 唯一性：对于类的每个对象，每次调用其成员函数时，都会有一个唯一的this指针与之对应，确保了成员函数能够操作正确的对象数据。

## this指针的用处

- 一个对象的this指针并不是对象本身的一部分，不会影响sizeof(对象)的结果。
- this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候（全局函数，静态函数中不能使用this指针）
- 编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针， 编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行。

## 需要显示使用this指针的场景
- 区分重名成员：当局部变量或者函数参数与类的成员变量或成员函数重名时，可以使用this指针来区分
  - this->n = n （不能写成n = n）
- 链式调用：在某些设计模式中，例如链式调用，this指针可以返回当前对象的引用，从而实现连续调用同一个对象的多个方法。
- 在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this；
- 避免参数传递：在类的方法中，使用this指针可以直接访问所属对象的数据成员，无需将对象本身作为参数传递给方法。

## 类的this指针有以下特点

1. this只能在成员函数中使用，全局函数、静态函数都不能使用this。实际上，成员函数默认第一个 参数为T * const this

```c++
class A
{
public:
    int func(int p){}
};
其中，func的原型在编译器看来应该是：
int func(A * const this,int p);
```

2. 由此可见，this在成员函数的开始前构造，在成员函数的结束后清除。这个生命周期同任何一个 函数的参数是一样的，没有任何区别。当调用一个类的成员函数时，编译器将类的指针作为函数的this 参数传递进去。

```c++
A a;
a.func(10);
//此处，编译器将会编译成： 
A::func(&a,10);
```

> 看起来和静态函数没差别，对吗？不过，区别还是有的。编译器通常会对this指针做一些优化，因此，this指针的传递效率比较高，例如VC通常是通过ecx（计数寄存器）传递this参数的。

3. 只有当对象被创建后 this 才有意义，因此不能在 static 成员函数中使用

## 几个this指针的易混问题

### this指针是什么时候创建的？

this在成员函数的开始执行前构造，在成员的执行结束后清除。
但是如果class或者struct里面没有方法的话，它们是没有构造函数的，只能当做C的struct使用。采用TYPE xx的方式定义的话，在栈里分配内存，这时候this指针的值就是这块内存的地址。采用new的方式创建对象的话，在堆里分配内存，new操作符通过eax（累加寄存器）返回分配的地址，然后设置给指针变量。之后去调用构造函数（如果有构造函数的话），这时将这个内存块的地址传给ecx，之后构造 函数里面怎么处理请看上面的回答

### this指针存放在何处？堆、栈、全局变量，还是其他？

this指针会因编译器不同而有不同的放置位置。可能是栈，也可能是寄存器，甚至全局变量。在汇编级别里面，一个值只会以3种形式出现：立即数、寄存器值和内存变量值。不是存放在寄存器就是存放在 内存中，它们并不是和高级语言变量对应的。

### this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针 又是如何找到“类实例后函数的”？

大多数编译器通过ecx（计数寄存器）寄存器传递this指针。事实上，这也是一个潜规则。一般来说，不同编译器都会遵从一致的传参规则，否则不同编译器产生的obj就无法匹配了。
在call之前，编译器会把对应的对象地址放到eax中。this是通过函数参数的首参来传递的。this指针在调用之前生成，至于“类实例后函数”，没有这个说法。类在实例化时，只分配类中的变量空间，并没有 为函数分配空间。自从类的函数定义完成后，它就在那儿，不会跑的

### this指针是如何访问类中的变量的？

如果不是类，而是结构体的话，那么，如何通过结构指针来访问结构中的变量呢？如果你明白这一点的 话，就很容易理解这个问题了。
在C++中，类和结构是只有一个区别的：类的成员默认是private，而结构是public。
this是类的指针，如果换成结构体，那this就是结构的指针了。

### 我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？

this指针只有在成员函数中才有定义。因此，你获得一个对象后，也不能通过对象使用this指针。所以，我们无法知道一个对象的this指针的位置（只有在成员函数里才有this指针的位置）。当然，在成员函数里，你是可以知道this指针的位置的（可以通过&this获得），也可以直接使用它。

### 每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？

普通的类函数（不论是成员函数，还是静态函数）都不会创建一个函数表来保存函数指针。只有虚函数 才会被放到函数表中。但是，即使是虚函数，如果编译期就能明确知道调用的是哪个函数，编译器就不会通过函数表中的指针来间接调用，而是会直接调用该函数。正是由于this指针的存在，用来指向不同的对象，从而确保不同对象之间调用相同的函数可以互不干扰。

### this指针的一个完整示例：

```c++
this指针的一个完整示例：
#include <iostream>
using namespace std;

class Student{
public:
    void setname(char *name);
    void setage(int age);
    void setscore(float score);
    void show();
private:
    char *name;
    int age;
    float score;
};

void Student::setname(char *name){
    this->name = name;
}
void Student::setage(int age){
    this->age = age;
}
void Student::setscore(float score){
    this->score = score;
}
void Student::show(){
    cout<<this->name<<"的年龄是"<<this->age<<"，成绩是"<<this->score<<endl;
}

int main(){
    Student *pstu = new Student;
    pstu -> setname("李华");
    pstu -> setage(16);
    pstu -> setscore(96.5);
    pstu -> show();

    return 0;
}
运行结果：
李华的年龄是16，成绩是96.5
```

- this 只能用在类的内部，通过 this 可以访问类的所有成员，包括 private、protected、public 属性的。
- 本例中成员函数的参数和成员变量重名，只能通过 ``this``区分。以成员函数 ``setname(char *name)``为例，它的==形参==``name``，和==成员变量==``name``重名，如果写作 ``name = name``;这样的语句，就是给==形参==``name``赋值(成员函数作用域内，形参会屏蔽成员变量)，而不是给==成员变量==``name``赋值。而写作 ``this -> name = name;``后，==\=左边的name==就是==成员变量==，==右边的name==就是==形参==，一目了然。

> 注意，this 是一个指针，要用->来访问成员变量或成员函数。
