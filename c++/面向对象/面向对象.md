# 面向对象

## 面向过程和面向对象

### **面向过程编程（Procedural Programming）**

1. 基本思想：面向过程编程侧重于程序的行为步骤，即如何通过一系列过程（函数、子程序）来解决问题。它以过程（或称为函数）为核心，将计算过程分解为一系列函数调用。
2. 特点：
    - 程序组织围绕功能模块，模块之间通过函数调用进行通信。
    - 数据和操作数据的过程分离，数据可以被多个函数共享和修改。
    - 侧重于执行步骤和逻辑控制流，易于理解和实现小型项目。
3. 优点：简单直观，执行效率高，对于小型项目或算法密集型应用尤为适合。
4. 缺点：随着项目规模的扩大，代码难以维护和复用，难以应对需求变更。

### **面向对象编程（Object-Oriented Programming, OOP）**

1. 基本思想：面向对象编程强调的是将问题领域中的实体抽象成对象，通过对象的属性（数据成员）和行为（成员函数）来描述和模拟现实世界。它基于“万物皆对象”的概念，通过对象的封装、继承和多态等机制来设计和实现软件。
2. 特点：
    - 程序围绕对象构建，对象包含了数据（属性）和对数据的操作（方法）。
    - 封装性保证了数据的安全性和隐藏性，继承支持代码复用，多态提供了灵活性和可扩展性。
    - 通过类和对象的概念，使得代码结构更加清晰，易于维护和扩展。
3. 优点：提高了代码的复用性、灵活性和可维护性，更适合大型复杂项目的开发。
4. 缺点：相比面向过程编程，面向对象编程可能引入更多的间接层，降低运行效率；学习曲线相对陡峭，设计不当可能导致系统结构复杂。

## 面向对象的三大特性

- 封装：将具体的实现过程和数据封装成一个函数，只能通过接口进行访问，降低耦合性。

- 继承：子类继承父类的特征和行为，子类有父类的非 private 方法或成员变量，子类可以对父类的方法进行重写，增强了类之间的耦合性，但是当父类中的成员变量、成员函数或者类本身被 final 关键字修饰时，修饰的类不能继承，修饰的成员不能重写或修改。

- 多态：多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。

### 1.封装（Encapsulation）

- 核心思想：封装的核心思想是将数据（属性）和操作数据的方法（行为）捆绑在一起，并限制对这些数据的直接访问。在C++中，封装是通过访问修饰符（public, protected, private）来实现的。
  - public：公有成员对所有类内外的代码都是可见的。
  - protected：受保护的成员对派生类可见，但对类外的代码不可见。
  - private：私有成员仅对定义它们的类内部可见。
- 重要性：提高数据安全性，减少耦合度，使得组件更容易独立修改而不影响其他部分。
- 深入理解：封装不仅仅是隐藏数据，更重要的是暴露有意义的接口给外部使用，确保类的使用者只能通过这些接口与对象交互，从而维护对象的完整性和一致性。

### 2.继承（Inheritance）

- 基本概念：继承允许创建一个新类（派生类），继承现有类（基类）的属性和行为，并可以添加或重写这些行为。
  - 基类：提供共通的属性和方法。
  - 派生类：继承基类的属性和方法，并可以添加或重写以满足特定需求。
- 目的：促进代码复用，支持类型和行为的层次结构。
- 注意事项：滥用继承可能导致结构复杂、耦合度高。应遵循里氏替换原则（Liskov Substitution Principle），即派生类应当能够替换掉基类，并且不会影响到程序的正确性。

### 3.多态（Polymorphism）

- 含义：多态是指允许不同类的对象对同一消息做出响应的能力，即同一个接口可以有多种实现方式。
- 类型：主要包括编译时多态（通过函数重载、模板实现）和运行时多态（通过虚函数和动态绑定实现）。
- 价值：增加代码的灵活性和可扩展性，使得程序可以在不修改原有代码的情况下应对变化。

#### 静态多态（编译时多态）

静态多态性是在编译阶段就确定下来的，最常见的形式是函数重载和运算符重载。

- 函数重载：允许在同一作用域内有多个同名函数，只要它们的参数列表不同（参数类型或个数），编译器就会根据传入的参数类型自动选择正确的函数版本。这是编译时多态的一个例子，因为调用哪个函数在编译期间就能决定。

- 运算符重载：类似于函数重载，允许为运算符提供多种实现，具体调用哪个版本同样在编译时决定。

#### 动态多态（运行时多态）

动态多态性是在程序运行时确定的，C++主要通过虚函数（virtual functions）和抽象类（abstract classes）来实现这一特性。

- 虚函数：在基类中声明为virtual的成员函数，允许在派生类中被重写。使用虚函数的关键在于动态绑定（或称为迟绑定、晚期绑定），这意味着调用虚函数时，真正执行的函数版本直到运行时才能确定，取决于所调用对象的实际类型。虚函数的调用通常通过基类的指针或引用完成，这样编译器会在运行时查找虚函数表（vtable），以确定应该调用哪个派生类的函数。

- 抽象类：包含至少一个纯虚函数（在声明时加上= 0的虚函数）的类，不能直接实例化，通常作为接口使用，迫使派生类实现纯虚函数，从而保证了多态性。

- 虚析构函数：为了确保通过基类指针删除派生类对象时，派生类的析构函数也能被正确调用，建议将基类的析构函数也声明为虚函数。

**实现细节:**

- 虚函数表（VTable）：C++编译器为含有虚函数的每个类生成一个虚函数表，这张表中存储了该类及其所有基类的虚函数地址。每个对象都有一个指向相应虚函数表的指针（虚指针，vptr），这个指针在对象创建时初始化。

- 多态的调用过程：当通过基类指针或引用调用一个虚函数时，编译器实际上访问的是对象的vptr，然后通过vptr找到虚函数表，进而找到正确的函数地址并调用。
