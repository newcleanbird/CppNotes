# 函数对象
函数对象（Function Object），也被称为仿函数（Functor），是C++中一种重要的编程概念，它允许用户自定义类型像函数那样被调用。函数对象可以是普通的类对象，但通过重载其operator()，使其成为一个可调用的对象。这种设计不仅灵活，还能利用类的特性（如数据成员、继承、多态）来增强功能，使得函数对象成为函数式编程和泛型编程中的强大工具。

## 基本概念
1. 重载operator()：函数对象的核心在于重载了调用运算符operator()，这使得对象能够像函数那样被调用。例如：
```Cpp
class Adder {
public:
    int operator()(int a, int b) const {
        return a + b;
    }
};
```
上面的Adder类就是一个简单的函数对象，通过Adder对象可以调用operator()来执行加法操作。

2. 数据成员：与普通函数不同，函数对象可以拥有状态，即数据成员。这意味着函数对象的行为可以根据其内部状态而变化。

3. 作为参数传递：由于函数对象是对象，因此可以作为参数传递给其他函数或存储在容器中，这在算法定制和策略模式中尤为有用。

### 简单函数对象/仿函数
```cpp
#include <iostream>

class Square Functor {
public:
    int operator()(int x) const {
        return x * x;
    }
};

int main() {
    Square Functor square;
    std::cout << "5 squared is: " << square(5) << std::endl; // 输出: 5 squared is: 25
    return 0;
}
```

## 仿函数的特点
1. 类结构：仿函数是一个类，它通过重载函数调用操作符operator()来模拟函数的行为。
2. 携带状态：与普通函数不同，仿函数可以是带有成员变量的类实例，因此它们能够保存状态信息，这是普通函数所不具备的能力。
3. 重用性和多态性：由于仿函数是类的实例，因此它们可以作为参数传递给其他函数，存储在容器中，或作为算法的一部分，这为代码的复用和多态提供了便利。
4. 泛型编程：在C++ STL（标准模板库）中，仿函数常用于算法中，作为算法行为的自定义策略，如std::sort可以通过仿函数来指定排序规则。


## 优点
- 灵活性：通过封装状态和行为，函数对象可以提供更灵活的解决方案。
- 类型安全：相比于函数指针，函数对象提供更好的类型安全，尤其是在使用模板时。
- 多态性：利用继承和虚函数，可以实现函数对象的多态行为。
- 可重用性：函数对象作为类实现，便于复用和扩展。

## C++ STL中的仿函数
C++标准库中有许多预定义的仿函数类，位于``<functional>``头文件中，比如``std::plus, std::minus, std::bind``, 以及C++11引入的``lambda``表达式，它们也可以视为一种匿名的仿函数。

## 实例应用
1. 标准库算法：C++标准库中的许多算法，如std::sort、std::find_if等，都接受函数对象作为参数，用于定制行为。
```cpp
std::vector<int> vec = {1, 2, 3, 4, 5};
std::sort(vec.begin(), vec.end(), std::greater<int>()); // 使用std::greater作为比较函数对象
```

2. Lambda表达式：C++11引入了Lambda表达式，它是一种更简洁的创建匿名函数对象的方式。Lambda表达式可以直接在代码中定义，并且可以捕获外部变量。
```cpp
auto addFive = [](int x) { return x + 5; }; // Lambda表达式定义的函数对象
std::cout << addFive(10) << std::endl; // 输出15
```

3. 策略模式：在策略模式中，函数对象可以作为策略接口，实现算法或策略的可插拔。

## 注意事项
- 性能：虽然函数对象提供了额外的功能，但在某些情况下，直接使用内联函数或模板元编程可能提供更好的性能。
- 复杂性：过度使用函数对象可能会增加代码的理解难度，特别是当函数对象的状态和行为变得复杂时。







