# 委派构造函数
委派构造函数是C++11引入的一项特性，它允许在一个类的构造函数中直接调用该类的另一个构造函数，从而实现构造过程中的代码重用和逻辑简化。

## 提出背景:构造函数冗余造成重复
委派构造函数也是C++11中对C++的构造函数的一项改进，其目的也是为了减少程序员书写构造函数的时 间。通过委派其他构造函数，多构造函数的类编写更加容易。
```cpp
class Info
{
	public:
		Info()
		:_type(0)
		,name('a')
		{
			InitRSet();
		}
		
		Info(int type)
		:_type(type)
		,name('a')
		{
			InitRSet(); 
		}
		
		Info(char a)
		:_type(0)
		,name(a)
		{
			InitRSet();
		}
	private:
		void InitRSet(){
			//初始化其他变量 
		}
	private:
	int _type;
	char _name;
	//... 
};
```
**上述构造函数除了初始化列表不同之外，其他部分都是类似的，代码重复。**
初始化列表可以通过：类内部成员初始化进行优化，但是构造函数体的重复在C++98中无法解决。
能否将：构造函数体中重复的代码提出来，作为一个基础版本，在其他构造函数中调用呢？


## 委派构造函数
所谓委派构造函数：就是指委派函数将构造的任务委派给目标构造函数来完成的一种类构造的方式。

基本概念：委托构造函数（Delegating Constructor）：在类的构造函数定义中，通过在其初始化列表中调用同一类的另一个构造函数来完成对象的初始化。这样可以避免构造函数代码的重复，使得构造逻辑更加集中和易于维护。

## 语法
假设有一个类Example，它有两个构造函数，其中一个构造函数可以通过委派调用另一个构造函数来完成初始化：
```cpp
class Example {
public:
    Example(int a) : value(a) {} // 目标构造函数
    Example(): Example(0) {}    // 委派构造函数，委托给上面的构造函数
private:
    int value;
};
```
在上面的例子中，Example()是一个委派构造函数，它通过在其初始化列表中调用Example(int)构造函数（目标构造函数），实现了对value成员的初始化。

## 作用
1. 减少代码重复：当多个构造函数有相似的初始化步骤时，可以将公共部分放在一个构造函数中，然后其他构造函数通过委派调用它，避免了重复编写相同的初始化代码。
2. 逻辑集中：使得构造逻辑更加集中和易于理解，因为共同的初始化逻辑只在一个地方定义。
3. 提高可维护性：如果初始化逻辑需要改变，只需要修改被委派的构造函数，所有通过委派调用它的构造函数都会自动采用新的初始化逻辑。

## 举例
```cpp
class Info
{
	public:
		//目标构造函数 
		Info()
		:_type(0)
		,name('a')
		,InitRSet()
		{
			
		}
		
		//委派构造函数 
		Info(int type)
		:Info()
		{
			_type = type;
		}
		
		//委派构造函数 
		Info(char a)
		:Info()
		{
			_char = a;
		}
	private:
		void InitRSet(){
			//初始化其他变量 
		}
	private:
	int _type;
	char _name;
	//... 
};
```
在初始化列表中调用”基准版本”的构造函数称为委派构造函数，而被调用的”基准版本”则称为目标构造函数。

## 注意事项
1. 循环委托：委派构造函数不能形成循环委托，即构造函数A不能委托构造函数B，而B又直接或间接地委托回A，这会导致编译错误。
2. 初始化列表：在委派构造函数中，除了委托调用外，不能包含其他成员的直接初始化。也就是说，所有成员的初始化都应当在被委托的构造函数中完成。
3. 构造函数链：可以形成构造函数链，即一个构造函数委派给另一个，另一个再委派给下一个，以此类推，但最终必须有一个构造函数不进行委派调用，实际执行成员的初始化。

## 使用场景
委派构造函数特别适用于那些具有多种构造方式，但每种构造方式都包含一部分相同初始化逻辑的类。例如，一个复杂的类可能需要从文件、网络或用户输入等多种来源加载数据，虽然数据来源不同，但加载后的初始化处理可能是相同的，这时候就可以利用委派构造函数来简化代码结构。

