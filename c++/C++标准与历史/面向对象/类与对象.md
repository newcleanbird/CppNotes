# 类与对象
## 类的定义
C++中的类可以看成C语言中的结构体升级版，结构体是一种构造类型，可以包含若干成员变量，成员变量的类型可以不同。
```cpp
class name
{
    //类体：成员函数和成员对象
};
```
关于class（类）的几点说明：
1. 类的定义的最后有一个分号，它是类的一部分，表示类定义结束，不能省略。
2. 一个类可以创建多个对象，每个对象都是一个变量
3. 类是一种构造类型，大小的计算方法和struct一样，需要字节对齐
4. 类成员变量的访问方法：通过 .或者->来访问
5. 成员函数是类的一个成员，出现在类中，作用范围由类来决定，而普通函数是独立的，作用范围是全局或者某个命名空间

struct ：内部默认是共有权限，结构体外部可以访问其内部成员
class：内部默认是私有权限，类的外部不能直接访问内部成员；可以手动声明为共有权限;

### 定义与声明
1. 声明和定义放在类内，对于成员函数如果放在类内定义，编译器可能会将其当为内联函数处理。
2. 声明和定义分离
```cpp
class ClassName {
public:          // 访问权限修饰符，这里是公共访问权限
    // 成员变量（数据成员）定义
    int dataMember1;
    double dataMember2;

    // 成员函数（方法）定义
    ClassName();     // 构造函数声明
    ~ClassName();    // 析构函数声明

    void someMethod();   // 其他成员函数声明

protected:         // 受保护的访问权限修饰符
    // 受保护的成员变量和函数可以被本类及继承类访问
    float protectedDataMember;

private:            // 私有访问权限修饰符
    // 私有成员只能被本类成员函数访问
    char privateDataMember;

    // 成员函数定义也可以放在类体内
    void privateMethod() {
        // 实现细节
    }
};

// 类外定义成员函数
ClassName::ClassName() {       // 构造函数定义
    // 初始化代码
}

ClassName::~ClassName() {      // 析构函数定义
    // 清理工作
}

void ClassName::someMethod() {  // 成员函数定义
    // 函数实现
}
```

### c++11声明时给缺省值 
注意这不是初始化
```cpp

class Date
{
	//对象实例化必须要有构造函数
    public:
	void Print()
	{
	    cout << _day << "/" << _month << "/" << _year<<endl;
    }
	int _day=1;//声明时给缺省值 
    int _month=2;
    int _year=3;
    A _aa;
};
```
- 如果初始化列表有初始化，那么就不用声明给的缺省值，
- 初始化列表没有初始化，那么就用声明时给的缺省值，
- 如果声明时也没有给缺省值，那么就是随机值了

### 类的访问限定符
1. Public（公有）
- 定义：public成员对所有用户都是可见的，无论是在类的内部还是外部，甚至是类的非成员函数和派生类中。
- 用途：通常用于类的接口部分，即那些希望外部用户能够直接访问和操作的成员，如公共方法（成员函数）和某些属性（数据成员）。

2. Protected（受保护）
定义：protected成员在类的外部不可见，但在类的派生类（子类）中是可见的，以及在类的内部。
用途：用于设计类的继承结构时，想要让基类的某些成员在派生类中可用，但不希望这些成员成为公共接口的一部分。

3. Private（私有）
定义：private成员仅在类的内部可见，对于类的外部以及派生类都是不可见的。
用途：用来隐藏类的实现细节，保护数据不被外部直接访问，通常用于数据成员，以实现封装和数据安全。

- 访问限定符的使用规则
  - 类的默认访问级别是private，如果不显式指定访问限定符，则成员默认为私有。
  - 结构体（struct）的默认访问级别是public，与类不同。
  - 访问限定符可以多次出现在类定义中，每次出现都影响其后的成员声明，直到遇到下一个访问限定符。
  - friend关键字可以被用来指定类的友元，友元可以访问类的私有和受保护成员。

#### 深入理解访问限定符
1. Public（公有）
- 思想：体现的是**接口暴露**的思想。公有成员是类对外提供的接口，是类与外部世界交流的桥梁。外部代码通过调用公有成员函数来与对象交互，而不必关心对象内部的具体实现细节。这符合封装原则，即隐藏实现细节，只暴露必要的接口。
- 关系：公有成员是类的用户（客户端代码）与类之间的直接联系。它允许类的使用者自由地读取和修改（如果是变量的话），或者调用（如果是函数的话）这些成员，从而利用类的功能。

2. Protected（受保护）
- 思想：代表了**继承与扩展**的设计思想。受保护成员在类的直接使用者面前是隐藏的，但是对派生类开放。这意味着基类设计者打算允许其继承者访问这些成员，以便在不破坏基类封装的前提下进行功能的扩展或修改。这支持了面向对象编程中的继承特性。
- 关系：受保护成员在类的层次结构中起到了承上启下的作用，它连接了基类和派生类，使得派生类能够访问并可能重定义基类的部分内部操作，同时保持这些操作对非继承关系的外部代码的不可见性。

3. Private（私有）
- 思想：强调**封装与隐藏**。私有成员是类的内部实现细节，对外界完全隐藏。这一设计确保了类的内部数据和实现逻辑不会被外部代码无意或恶意地修改，有助于维护类的完整性和稳定性。私有成员的存在使得类能够控制对其状态的访问和修改方式，是实现信息隐藏和封装的关键。
- 关系：私有成员与类的其他部分（特别是公有成员函数）之间形成了内部协作的关系，公有函数作为对外的接口，管理对私有数据的访问。这种设计模式鼓励了数据抽象，即将复杂的数据处理过程隐藏在简单易用的接口之后。

### 类的作用域
1. 定义与范围：类的作用域是由一对花括号 {} 包围的区域，定义了类的所有成员。在这个作用域内声明的任何名称（变量、函数等）都只在这个类内部有效。
2. 在类的作用域内，成员可以直接通过名称引用，无需额外的限定符。而在类的外部，访问类的非静态成员时，需要通过对象实例、引用或指针结合成员访问运算符（.或->）。
3. 静态成员（包括数据成员和成员函数）在类的作用域内定义，但它们不依赖于类的任何特定实例。静态成员可以通过类名直接访问，即使没有类的实例。
4. 外部定义：当在类定义外部实现成员函数时，需要使用作用域解析运算符 :: 来指定该函数属于哪个类。例如，ClassName::memberFunction() 表明 memberFunction 是 ClassName 类的成员。
5. 枚举与常量：类作用域内可以定义枚举和常量，这有助于封装和避免名称冲突，同时也使得这些元素在类的整个生命周期内保持一致性和可访问性。

### 类的成员
类的成员可以分为：
1. 类成员变量(属性)
2. 类成员函数(方法)
3. 类成员对象

```c++
class Student{
public:
    //成员变量
    char *name;
    int age;
    float score;
    //成员函数
    void say();  //函数声明
};
//函数定义
void Student::say(){
    cout<<name<<"的年龄是"<<age<<"，成绩是"<<score<<endl;
}
```

#### 数据成员(Data Members)
- 字段（Fields/Member Variables）：存储类对象的状态信息，可以是基本数据类型或者复合类型（如数组、指针、其他类的对象）。
- 常量（Constants）：定义类中不可更改的值。
- 静态成员变量（Static Data Members）：属于类本身，而不属于类的任何一个特定对象。所有对象共享同一份静态成员变量的副本。

关键字`const`请具体参考:[const](../关键字与限定符/const.md)
关键字`static`请具体参考:[static](../关键字与限定符/static.md)

#### 函数成员(Function Members)
- 方法（Methods/Member Functions）：定义类的行为，可以访问和修改类的数据成员。可以是虚函数（virtual），用于实现多态。
- 构造函数（Constructors）：用于创建和初始化类的对象。
- 析构函数（Destructors）：自动调用以释放对象占用的资源。
- 静态成员函数（Static Member Functions）：不依赖于类的实例，可通过类名直接调用，通常用于操作静态数据成员或执行不涉及对象状态的操作。
- 友元函数（Friend Functions）：虽不是类的成员，但可以访问类的私有和保护成员，声明时使用friend关键字。

注意：
- 在类体中直接定义函数时，不需要在函数名前面加上类名，因为函数属于哪一个类是不言而喻的。
- 但当成员函数定义在类外时，就必须在函数名前面加上类名予以限定。::被称为域解析符（也称作用域运算符或作用域限定符），用来连接类名和函数名，指明当前函数属于哪个类。
- 成员函数必须先在类体中作原型声明，然后在类外定义，也就是说类体的位置应在函数定义之前。

1. 在类体中和类体外定义成员函数的区别

- 在类体中定义的成员函数会自动成为内联函数，在类体外定义的不会。当然，在类体内部定义的函数也可以加 inline 关键字，但这是多余的，因为类体内部定义的函数默认就是内联函数。
- 内联函数一般不是我们所期望的，它会将函数调用处用函数体替代，所以我建议在类体内部对成员函数作声明，而在类体外部进行定义，这是一种良好的编程习惯，实际开发中大家也是这样做的。
- 当然，如果你的函数比较短小，希望定义为内联函数，那也没有什么不妥的。
- 如果你既希望将函数定义在类体外部，又希望它是内联函数，那么可以在定义函数时加 inline 关键字。当然你也可以在函数声明处加 inline，不过这样做没有效果，编译器会忽略函数声明处的 inline，

```c++
下面是一个将内联函数定义在类外部的例子：:
class Student{
public:
    char *name;
    int age;
    float score;
    void say();  //内联函数声明，可以增加 inline 关键字，但编译器会忽略
};
//函数定义
inline void Student::say(){
    cout<<name<<"的年龄是"<<age<<"，成绩是"<<score<<endl;
}
```

- 这样，say() 就会变成内联函数。
- 这种在类体外定义 inline 函数的方式，必须将类的定义和成员函数的定义都放在同一个头文件中（或者同一个源文件中），否则编译时无法进行嵌入（将函数代码的嵌入到函数调用出），具体原因我们已在《如何规范地使用C++内联函数》中进行了讲解
- 再次强调，虽然 C++ 支持将内联函数定义在类的外部，但我强烈建议将函数定义在类的内部，这样它会自动成为内联函数，何必费力不讨好地将它定义在类的外部呢，这样并没有任何优势。

##### 特殊成员
- 运算符重载函数（Operator Overloading）：允许重定义运算符的行为，使其适用于自定义类型。
- 类型转换函数（Conversion Operators）：允许类的对象隐式或显式转换为其他类型。
- 属性（Properties）：C++标准库中没有直接的属性概念，但可以通过getter和setter方法模拟。
- 索引器（Indexers）：类似于属性，但通过索引访问，C++中没有直接的索引器语法，但可以通过重载operator[]实现。
- 事件（Events）：C#等语言中有事件的概念，但在C++中通常通过回调函数或者观察者模式实现。

#### 类成员对象(嵌套类)

- 一个类的成员变量如果是另一个类的对象，就称之为“成员对象”。
- 包含成员对象的类叫封闭类（enclosed class）。

1. 成员对象的构造与析构

- 出现成员对象时，如果成员对象的构造函数是有参构造函数，则该类的初始化列表需要对成员对象进行初始化。

```cpp
class Member
{
private:
    int i;
public:
    Member(int i) // 构造函数
    {
        this->i = i;
    }
};
class Test
{
private:
    class Member member;  // 类成员对象
public:
    Test(): member(1)   // 构造函数需要使用初始化列表，对成员对象进行初始化
    {
    }
};
```

- 一个有成员对象的类实例化时要先调用成员对象的构造函数，然后再调用该类的构造函数，析构时先调用该类的析构函数，再调用成员对象的析构函数。

```cpp
#include <iostream>
class Member
{
public:
    Member()
    {
        std::cout << "Member构造函数" << std::endl;
    }

    ~Member()
    {
        std::cout << "Member析构函数" << std::endl;
    }

};
class Test
{
private:
    Member member;
public:
    Test()
    {
        std::cout << "Test构造函数" << std::endl;
    }
    ~Test()
    {
        std::cout << "Test析构函数" << std::endl;
    }
};
int main()
{
    Test* test = new Test();
    delete test;

    return 0;
}
```

```c++
运行结果：
Member构造函数  // 先调用成员对象的构造函数，构造成员对象
Test构造函数    // 再调用类的构造函数，初始化其他成员
Test析构函数    // 析构函数先调用类的构造函数，完成对成员的释放
Member析构函数  // 析构函数再调用成员对象的析构函数
```

#### 嵌套类
嵌套类（Nested Classes）：一个类定义在另一个类内部，可以访问外部类的私有和保护成员。
![嵌套类](../面向对象/嵌套类-内部类.md)

### 类的实例化（创建对象）
类的实例化指的是根据类定义创建类的对象的过程。对象是类的实例，它包含了类定义的数据成员和成员函数。创建类的对象后，就可以通过这个对象来访问和操作类的成员。以下是创建对象的基本步骤和注意事项：

1. 创建对象的基本语法
```cpp
ClassName objectName;
```
- ClassName 是类的名称。
- objectName 是你给对象取的名字，也就是对象的实例名。

2. 注意事项
- 默认构造函数：如果类没有定义任何构造函数，编译器会自动生成一个默认构造函数，用于初始化对象。如果有自定义构造函数，需要显式调用或由编译器根据情况选择合适的构造函数。
- 内存分配：每个对象在内存中都会分配独立的空间，用于存储其数据成员的值。因此，即使创建了多个相同的类的对象，每个对象的数据也是独立的。
- 动态对象：除了在栈上创建对象，还可以使用 new 操作符在堆上动态创建对象。动态对象需要手动使用 delete 释放内存。

#### 类实例化的不同方式
1. 静态创建（栈上创建对象）
这是最直接和常见的创建对象方式，对象在栈上分配内存，其生命周期通常与创建它的作用域相关联。
```c++
Student liming;           // 省略class
class Student xiaoming;   // 与上等价，后均采用省略class的版本
```

2. 动态创建（堆上创建对象）
使用`new`运算符在堆上分配内存并创建对象，需要手动管理内存。
```cpp
Student *ptr1 = new Student();
```

3. 拷贝构造函数创建
使用已存在对象创建新对象，复制其数据成员。
```cpp
MyClass obj1;
MyClass obj2(obj1); // 使用拷贝构造函数创建新对象
```

4. 移动构造函数创建
C++11引入的新特性，用于高效地转移资源所有权而非复制资源，特别是在对象即将被销毁的情况下。
```cpp
MyClass obj1;
MyClass obj2(std::move(obj1)); // 使用移动构造函数创建新对象
```

5. 委托构造
C++11开始支持，一个构造函数可以委托另一个构造函数来执行其初始化操作。
```cpp
class MyClass {
public:
    MyClass(int a) : MyClass(a, 0) {} // 委托构造
    MyClass(int a, int b) : a_(a), b_(b) {}
private:
    int a_, b_;
};

MyClass obj(10); // 通过委托构造创建对象
```

6. 显式类型转换构造函数（构造函数）
使用构造函数进行类型转换，但需要注意可能引发的歧义或不明确性。
```cpp
class MyClass {
public:
    explicit MyClass(int val) : value(val) {} // 显式构造函数
private:
    int value;
};

MyClass obj = 10; // 错误，因为构造函数是显式的
MyClass obj(10); // 正确
```
#### 对象数组
1. 静态对象数组
静态对象数组在编译时分配内存，并且数组的大小固定。对象存储在栈上，数组的生命周期与声明它的作用域相同。
```c++
Student allStudent[100];
Student allStudent[] = {Student(1), Student(2), Student(3)}; // 静态创建对象数组，同时调用构造函数初始化每个元素
```

2. 动态对象数组
动态对象数组在运行时分配内存，允许在程序执行过程中确定数组的大小。这类数组存储在堆上，需要手动管理内存（使用new[]分配，delete[]释放）。
```cpp
Student* pStudent = new Student[3];
Student* pStudent = new Student[3]{Student(1), Student(2), Student(3)};
```

3. 使用STL，如vector
```cpp
vector<Student> vec_Stu(m); // 创建存储m个Student的容器
```

### 访问类对象成员
1. 通过对象名直接访问（对象实例访问）
这是最常见的访问方式，适用于类的公有（public）成员。
```cpp
class MyClass {
public:
    int publicVar;
    void publicMethod() {}
private:
    int privateVar;
    void privateMethod() {}
};

int main() {
    MyClass obj;
    obj.publicVar = 10; // 访问公有数据成员
    obj.publicMethod(); // 调用公有成员函数
    // obj.privateVar 和 obj.privateMethod() 不可直接访问，因为它们是私有的
}
```

2. 通过指针访问
当使用对象指针时，可以使用箭头（->）操作符访问成员。
```cpp
MyClass* ptr = new MyClass();
ptr->publicVar = 20; // 通过指针访问公有数据成员
ptr->publicMethod(); // 通过指针调用公有成员函数
delete ptr; // 记得释放内存
```

3. 通过引用访问
引用与指针相似，但使用更直接，同样可以访问对象的成员。
```cpp
MyClass& ref = obj;
ref.publicVar = 30; // 通过引用访问公有数据成员
ref.publicMethod(); // 通过引用调用公有成员函数
```

4. 友元访问
友元类或友元函数可以直接访问另一个类的私有和保护成员。
```cpp
class FriendClass;
class MyClass {
    friend class FriendClass; // 声明FriendClass为友元类
    // ...
};

class FriendClass {
public:
    void accessMyClass(MyClass& mc) {
        mc.privateVar = 40; // 通过友元关系访问私有成员
    }
};
```

5. 公有成员函数作为接口
通过类的公有成员函数（通常称为getter/setter）来间接访问私有或保护成员，这是遵循封装原则的常用方法。
```cpp
class MyClass {
private:
    int privateVar;
public:
    void setPrivateVar(int value) { privateVar = value; }
    int getPrivateVar() const { return privateVar; }
};

MyClass obj;
obj.setPrivateVar(50); // 间接访问私有成员
int value = obj.getPrivateVar(); // 获取私有成员的值
```

>小节：
访问类对象的不同方式取决于成员的访问级别（public、private、protected）以及你是如何引用对象的（直接、通过指针、引用、友元等）。理解这些访问机制是掌握C++面向对象编程的基础。

### 类对象的大小（sizeof）
- 一个类的大小，是成员变量大小之和（存在内存对齐）。
[内存对齐](../编译内存相关/内存对齐.md)

#### ==空类的大小为1==
对于空类实例化的对象的大小，空类的大小为1，因为编译器给空类一个字节来表示这个类实例化的对象，（可以认为这个类实例化的对象存在的证明）（也就是占位）。

具体原因：
1. 独一无二的地址：C++标准要求每个对象实例在内存中必须有唯一的地址。如果空类的大小为0，则创建此类的多个实例时，这些实例在内存中将会占据相同的地址，这将导致无法区分不同的对象实例，也无法正确地指向它们。因此，为了确保每个空类实例都能拥有唯一的地址，编译器会给空类分配至少1字节的大小。

2. 内存对齐：内存对齐是出于性能考虑，大多数系统要求数据结构的起始地址能够被特定的字节数（通常是其最大数据类型的大小）整除，以提高访问效率。即使是空类，也需要遵守这一规则。分配1字节确保了即使是最小的对齐要求也能被满足。

3. 优化：虽然空类实例因为这个隐藏字节而占用1字节，但在某些情况下，如空类作为基类参与多态或继承时，编译器可能会实施空基类优化（Empty Base Class Optimization, EBCO），以减少空基类在派生类对象中的内存占用。这意味着在实际的复杂对象布局中，空类可能不会造成额外的内存开销。

4. 编译器实现：尽管标准只要求空类实例具有唯一的地址，但主流编译器通常通过分配1字节大小来简单且一致地满足这一要求。这避免了实现上的复杂性，并且对性能影响微乎其微。

#### 静态数据成员--为0

静态数据成员被编译器放在程序的一个global data members(静态存储区)中，它是类的一个数据成员，但不影响类的大小。不管这个类产生了多少个实例，还是派生了多少新的类，静态数据成员只有一个实例。静态数据成员，一旦被声明，就已经存在。

#### 包含虚函数的类--只计算一个虚指针

不管有多少个虚函数，只有一个虚指针,vptr的大小。

- 32位操作系统4字节
- 64位操作系统 8字节

#### 继承

1.普通单继承,继承就是基类+派生类自身的大小(注意字节对齐)
注意：类的数据成员按其声明顺序加入内存，无访问权限无关，只看声明顺序。

2.虚单继承，派生类继承基类vptr

```c++
#include<iostream>
 
using namespace std;
 
class A
{
public:
    char a;
    int b;
};
 
/**
 * @brief 此时B按照顺序：
 * char a
 * int b
 * short a
 * long b
 * 根据字节对齐4+4+8+8=24
 *
 * 或编译器优化
 * char a
 * short a
 * int b
 * long b
 * 根据字节对齐2+2+4+8=16
 */
class B:A
{
public:
    short a;
    long b;
};
 
/**
* 把A的成员拆开看，char为1，int为4，所以是1+（3）+4+1+（3）=12，（）为字节补齐
*/
class C
{
    A a;
    char c;
};
 
class A1
{
    virtual void fun(){}
};
 
class C1:public A1
{
};
 
 
int main()
{
    cout<<"sizeof(A):"<<sizeof(A)<<endl; // 8
    cout<<"sizeof(B):"<<sizeof(B)<<endl; // 16
    cout<<"sizeof(C):"<<sizeof(C)<<endl; // 12
    cout<<"sizeof(A1):"<<sizeof(A1)<<endl; // 8
    /**
     * @brief 对于虚单函数继承，派生类也继承了基类的vptr，所以是8字节
     */
    cout<<"sizeof(C1):"<<sizeof(C1)<<endl; // 8
    return 0;
}
```

#### 小节
- 一个类中，虚函数本身、成员函数（包括静态与非静态）和静态数据成员都是不占用类对象的存储空间。
- 对于包含虚函数的类，不管有多少个虚函数，只有一个虚指针vptr的大小。
- 普通继承，派生类继承了所有基类的函数与成员，要按照字节对齐来计算大小。
- 虚函数继承（多态），不管是单继承还是多继承，都是继承了基类的vptr。(32位操作系统4字节，64位操作系统 8字节)！
- 虚继承(菱形继承),继承基类的vptr。

### this指针

this 是 C++ 中的一个关键字，也是一个 const 指针，它指向当前对象，通过它可以访问当前对象的所有成员。

> 所谓当前对象，是指正在使用的对象。例如对于stu.show();，stu 就是当前对象，this 就指向 stu。

- this 实际上是成员函数的一个隐式形参，本质上是成员函数的局部变量。在调用成员函数时将对象的地址作为实参传递给 this。不过 this 这个形参是隐式的，它并不出现在代码中，而是在编译阶段由编译器默默地将它添加到参数列表中。
- this指针只能在成员函数中使用，并且只有在通过对象调用成员函数时才给 this 赋值。
- 在全局函数、静态成员函数中都不能用this。
- this指针是类的指针，指向对象的首地址。
- this指针只有在成员函数中才有定义，且存储位置会因编译器不同有不同存储位置。

this指针详解：[this指针](../面向对象/this指针.md)

### friend友元函数和友元类
![frirend友元](../面向对象/friend友元.md)

## 类的默认成员函数
默认的其中一个含义：你不显式写，系统会默认生成。（只是其中一个含义会面会讲其他含义）
1. 默认构造函数（Default Constructor）：如果一个类没有定义任何构造函数，编译器会自动生成一个默认构造函数，这个构造函数不接受任何参数，用于默认初始化类的对象。

2. 拷贝构造函数（Copy Constructor）：当一个新对象被初始化为已存在对象的副本时调用。如果未自定义，编译器会生成一个，该函数复制所有非静态数据成员。

3. 赋值运算符重载函数（Assignment Operator）：用于将一个对象的值赋给另一个同类型的对象。如果未自定义，编译器会提供一个默认的，它按位复制数据成员。

4. 析构函数（Destructor）：当对象生命周期结束时自动调用，用于释放对象所占用的资源。如果没有自定义，编译器会生成一个空的析构函数。

自从C++11引入移动语义之后，还有另外两个与右值引用相关的默认成员函数：

5. 移动构造函数（Move Constructor）：用于从一个临时对象或即将销毁的对象高效地“移动”资源到新对象，而非复制资源。如果类中有动态分配的内存或其他可移动资源，并且没有自定义移动构造函数，编译器会生成一个。

6. 移动赋值运算符（Move Assignment Operator）：与移动构造函数类似，用于将一个临时对象或即将销毁的对象的资源移动到已有对象上，以替代其当前的值。同样，如果未自定义且适用，编译器会自动生成。

除此之外，还有两个与取地址相关的操作符也可能有默认实现，尽管它们不是针对特定对象的操作：

7. 取地址操作符（Address-of Operator）：返回对象的地址，通常不需要也不应该被重载，除非有特殊需求。

8. 常量取地址操作符（Const Address-of Operator）：返回对象的常量地址，当对象本身是常量时使用，同样，通常不需要重载。

### 构造函数
1. 目的
保证每一个成员变量有一个初始值。

2. 特性
    1. 函数名与类名相同。
    2. 无返回值。
    3. 对象实例化时编译器自动调用对应的构造函数，类实例化时必须要有构造函数
    4. 构造函数可以重载
    5. **没有显式定义构造函数则编译器会生成一个无参的默认构造函数，如果有显式定义编译器不再生成**
    6. 系统默认生成的构造函数对自定义类型调用自己的构造函数，内置类型不做处理

```cpp
Date d1;    // 默认构造无参
Date d2();  // 无参不能加括号 错误！无法区分函数声明
```

#### 默认构造函数（Default Constructor）
- 无参数：默认构造函数不接受任何参数。这是它区别于其他构造函数（如带参数构造函数）的主要标志。

- 自动调用：当创建一个类的对象且没有提供初始化列表或参数时，编译器会自动调用默认构造函数。此外，在数组或容器初始化等场景中，如果没有显式提供初始化值，也会调用默认构造函数。

- 编译器生成：如果程序员没有显式定义任何构造函数，编译器会自动为类生成一个默认构造函数。这个默认构造函数可能什么都不做（无用的默认构造函数），或者如果类的数据成员有类内初始值（C++11起支持），则会用这些初始值来初始化数据成员。

- 初始化：默认构造函数会执行以下操作之一：
  - 对于基类子对象和成员类对象，它会调用它们的默认构造函数（递归进行）。
  - 对于数据成员，如果它们是POD（Plain Old Data）类型且没有类内初始值，则默认构造函数不会执行特别的初始化操作，这些成员将保持未初始化状态或默认初始化状态（数值类型通常为0或NULL，指针类型为NULL）。
  - 如果数据成员有类内初始值（C++11起），则使用这些初始值进行初始化。

- 覆盖与抑制：一旦程序员定义了任何构造函数（即使是其他带参数的构造函数），编译器将不再自动生成默认构造函数。如果仍然需要默认构造函数的行为，可以显式定义一个不带参数的构造函数，并且可以选择使用=default关键字来显式要求编译器生成默认构造函数的行为。

- 使用``=default``和``=delete``：C++11引入了=default和=delete语法，允许程序员显式要求使用或禁止生成默认构造函数。=default可以用来明确指定即使类中还有其他构造函数，也要生成一个默认构造函数。=delete则可以用来禁止生成默认构造函数，防止类被默认实例化。


#### 初始化列表
1. 语法：初始化列表位于构造函数的头部，紧跟在构造函数的参数列表之后，由一个冒号（:）引导，随后是用逗号分隔的成员变量初始化器列表。
```cpp
ClassName::ClassName(arg1, arg2) : member1(value1), member2(value2), ...
{
    // 构造函数体
}
```
2. 作用：
- 效率：对于非静态的非POD（Plain Old Data）类型成员，如自定义类的对象，直接初始化可以避免两次构造（一次默认构造再赋值）。
- 必须使用：对于**常量成员**、**引用类型成员** 和 **自定义类型的成员(没有默认构造函数)**，必须使用初始化列表，因为这些成员在声明后不能被赋值。
  - 即：这些变量都是在定义时就要给初始值进行初始化的。
- 基类构造：同样，如果类从基类继承，可以通过初始化列表来调用基类的构造函数。

3. 初始化顺序：成员变量的初始化顺序与其在类声明中的声明顺序一致，而非初始化列表中的顺序。

4. 优化资源分配：直接初始化可以避免不必要的临时对象创建，尤其是当成员变量是复杂类型或者初始化开销较大时。

5. 编译器行为：如果在构造函数体内使用赋值操作符初始化成员变量，这实际上是进行了默认构造后再赋值的操作，对于某些类型可能不够高效，也不适用于常量或引用成员。

注意：
1. 构造函数中的语句只能将其赋值（可以多次）, 不叫初始化（只能初始化一次，即每个成员对象只能在初始化列表中出现一次）

2. 初始化列表有值则用初始化列表的 不用声明时给缺省值的缺省值 而是用构造函数的缺省值

#### 隐式类型转化  explicit 
- 作用：explicit 修饰的构造函数有禁止隐式类型转换
![explicit](../关键字与限定符/explicit.md)


### 析构函数
析构函数在C++中是一个特殊的成员函数，它没有返回类型（连void也没有），也没有参数。析构函数的主要职责是在对象生命周期结束时执行清理工作，释放对象可能占用的资源。
1. 作用
- 主要清理堆区的资源，防止内存泄漏
- 要显示写拷贝构造函数一般就要显示写析构函数，（因为涉及深浅拷贝问题）

2. 特性
   1. 自动调用：析构函数是自动执行的，不需要程序员显式调用。当对象生命周期结束时，如对象离开作用域、delete一个动态分配的对象、容器（如std::vector）销毁其元素时，析构函数会被自动调用。
   2. 资源清理：析构函数主要用于释放对象占用的资源，如动态分配的内存、关闭文件、断开网络连接等。这有助于避免资源泄露，保持程序的健壮性。
   3. 生命周期管理：与构造函数相对应，构造函数用于初始化对象，而析构函数负责清理。它们共同构成了对象的完整生命周期管理。
   4. 继承与组合：
      1. 继承：在继承体系中，当派生类的析构函数执行完毕后，会自动调用基类的析构函数，保证基类资源也被正确释放。析构顺序与构造顺序相反。
      2. 组合：如果一个类中有其他类的对象作为成员，该成员对象的析构函数会在本类析构函数之前被调用，遵循“后构造先析构”的原则。
   5. 默认析构函数：如果开发者没有显式定义析构函数，编译器会自动生成一个默认的析构函数。默认析构函数通常不做任何操作，但对于不管理额外资源的基本类来说已足够。对于管理了资源的类，应当自定义析构函数以确保资源正确释放。
   6. 虚析构函数：在有多态需求的情况下，基类的析构函数应声明为虚拟的（virtual），以确保通过基类指针或引用来删除派生类对象时，派生类的析构函数能够被正确调用，避免资源泄露。

3. 析构顺序
- 先实例的对象先构造后析构
  - 为什么：因为对象是在函数中实例化的，函数调用会建立函数栈帧，对象的构造类似栈的先入后出。
- 构造顺序：全局对象（从上往下）-> 局部静态 -> 局部对象
- 销毁循序：局部对象（后定义先销毁）-> 局部静态 -> 全局对象(后定义先销毁)

即：
1. 数据成员的析构：首先，按照它们在类中声明的逆序调用类中非静态数据成员的析构函数。这是因为最后一个构造的数据成员应该是第一个被析构的。

2. 当前类析构函数体：接下来，执行当前类析构函数的函数体。这是用户定义的代码部分，用于执行特定的清理工作。

3. 基类析构：如果当前类是从另一个类继承而来，那么按照继承顺序的逆序调用基类的析构函数。最直接的基类的析构函数最后被调用，而离当前类最远的基类析构函数首先被调用。

4. 虚继承的处理：对于虚继承的情况，虚基类的析构函数会在所有派生类的析构完成后被调用，以确保虚基类的资源只被释放一次。这通常在所有非虚基类的析构函数调用之后发生。

简而言之，析构的顺序确保了从最“内部”的（最近构造的）部分开始析构，向外（最早构造的部分）进行，直到最终的基类和虚基类。这样的设计有助于避免资源泄露和确保正确的资源管理，尤其是在涉及到复杂对象层次结构和继承关系时。

### 拷贝构造
拷贝构造函数是C++中一个特殊的构造函数，其主要职责是使用一个已经存在的同类对象来初始化一个新的对象。拷贝构造函数允许你创建一个类的新实例，并将其初始化为现有实例的一个精确副本，包括所有的数据成员和资源。下面是关于拷贝构造函数的详细说明：

#### 定义
拷贝构造函数的定义具有以下特征：
- 函数名：与类名相同。
- 参数：仅有一个参数，该参数是对本类类型的对象的引用。为了防止实参被修改，通常使用const修饰，即const 类名 &。
- 返回值：没有返回值，连void也不需要指定。
- 访问权限：应当声明为public，以便在需要时可以从外部访问。

示例：
```cpp
class MyClass {
public:
    // 拷贝构造函数
    MyClass(const MyClass &other) {
        // 执行深拷贝或其他必要的初始化操作
        this->data = new int(*other.data); // 假设data是一个int指针，执行深拷贝
    }
    
private:
    int *data; // 成员变量
};
```

#### 写法注意
**注意：容易写出无穷递归**
```cpp
//拷贝构造
    Date(Date d)//调用拷贝构造 要传值传参 又要构造拷贝构造 无穷递归
    {
        _day = d._day;
        _month = d._month;
        _year = d._year;
    }
    *****************************以上错误例子
 
    Date(const Date& d)正确写法
    {
        _day  = d._day;
        _month = d._month;
        _year = d._year;
    }
```


#### 调用时机
拷贝构造函数会在以下几种情况下被自动调用：

1. 直接初始化：用一个已存在的对象直接初始化一个新对象时。
```cpp
MyClass obj1;
MyClass obj2(obj1); // 调用了拷贝构造函数
```

2. 作为函数参数传递：当对象作为参数以值传递给函数时。
```cpp
void func(MyClass obj);
MyClass obj1;
func(obj1); // 在这里调用拷贝构造函数创建obj的副本传递给func
```

3. 作为函数返回值：函数以类对象作为返回值且返回的是局部对象或参数对象时。
```cpp
MyClass func() {
    MyClass localObj;
    return localObj; // 返回前调用拷贝构造函数
}
MyClass obj = func(); // 调用拷贝构造函数接收返回值
```

4. 赋值操作的副产品：虽然这不是直接调用拷贝构造函数的场景，但在某些旧的编译器或特定情境下，复杂的赋值操作可能间接触发拷贝构造函数（现代编译器通常会对这种情况进行优化，使用移动构造函数或复制省略优化）。

#### 浅拷贝与深拷贝
- 浅拷贝：默认的拷贝构造函数执行的是浅拷贝，即只复制对象的非静态数据成员的值，如果成员是指针，则只复制指针的值，而不是指针所指向的数据。这可能导致两个对象共享同一块内存，当其中一个对象修改这块内存时，会影响到另一个对象。

- 深拷贝：为了避免浅拷贝带来的问题，需要自定义拷贝构造函数来执行深拷贝，即除了复制指针的值外，还为新对象分配新的内存，并复制原对象指针所指向的数据。

**需要深拷贝的情况**：
1. 含有指针成员变量的类：当类中包含指向动态分配内存的指针成员时，必须执行深拷贝以确保每个对象拥有其数据的独立副本。否则，浅拷贝会导致两个对象共享同一块内存，从而在对象生命周期管理上出现问题，比如重复释放同一块内存。

2. 资源管理类：如文件句柄、数据库连接、网络套接字等资源的封装类。这类对象需要确保每个实例管理独立的资源，深拷贝可以保证复制的对象拥有自己的资源副本，避免资源共享导致的冲突或错误。

3. 容器类：如果你自定义了包含其他对象或指针的容器（如数组、链表、树等），并且这些元素也需要独立存在，则容器的拷贝需要执行深拷贝，以确保容器内的每一个元素都是独立的副本。

4. 包含复杂数据结构的类：如果类中嵌套了其他复杂类型，特别是那些含有指针或动态分配的成员，深拷贝就显得尤为重要。这包括类的类成员、自定义数据结构等。

5. 图形对象或大对象：在处理图像、声音、视频等大型数据对象时，由于数据量大且通常是动态分配的，深拷贝可以确保每个对象有其专属的数据缓冲区，避免数据错乱。

6. 多线程环境下的共享数据：在多线程应用中，为了线程安全，可能需要为每个线程提供独立的数据副本，此时深拷贝是必要的，以防止数据竞争和一致性问题。

### 拷贝赋值运算符 / 赋值运算符重载函数
赋值运算符重载函数，也称为拷贝赋值运算符，是C++中一种特殊的成员函数，用于定义当使用赋值运算符(=)将一个对象的值赋予另一个对象时的行为。这个函数允许你控制对象之间如何进行值的复制，特别是在涉及复杂数据结构或资源管理时，自定义赋值运算符重载函数变得尤为重要。

#### 定义
赋值运算符重载函数的一般形式如下：
```cpp
class MyClass {
public:
    // 赋值运算符重载函数
    MyClass& operator=(const MyClass& other) {
        // 实现赋值逻辑
        if (this != &other) { // 防止自我赋值
            // 深拷贝或其他必要的赋值操作
            data = new int(*other.data); // 假设data是一个int指针，执行深拷贝
        }
        return *this; // 返回当前对象的引用，支持链式赋值
    }

private:
    int* data; // 成员变量
};
```

#### 特点
1. 返回类型：通常返回当前对象的引用(MyClass&)，这样可以支持连续赋值，如a = b = c。
2. 参数：一个常量引用到同类对象(const MyClass& other)，这避免了不必要的拷贝，并允许对const对象进行赋值。同时，加const可以防止在赋值过程中修改源对象。
3. 自我赋值检查：在赋值逻辑开始前，通过检查this != &other来判断是否为自我赋值，这一步是防止自我赋值导致的问题，如重复释放内存。
4. 深拷贝：如果类中包含指针成员，需要执行深拷贝，即复制指针所指向的数据，而不是仅仅复制指针的值。
5. 资源管理：确保正确地处理和转移资源（如内存、文件描述符等），并释放原有资源，避免资源泄露。

#### 何时需要重载
1. 当类中含有动态分配的内存或资源时。
2. 当类需要执行特殊的逻辑或验证，在赋值操作发生时。
3. 为了提升效率，避免不必要的操作，如当对象非常大或复杂时。

#### 注意事项
1. 返回值：返回当前对象的引用可以让赋值操作支持连续赋值。
2. 异常安全：在实现过程中要考虑异常安全，确保即使在发生异常时也不会留下资源泄露。
3. 复制省略与移动语义：C++11引入了移动语义，有时使用移动赋值运算符比拷贝赋值更高效。如果适用，应同时考虑重载移动赋值运算符。
4. 避免无穷递归：如果在赋值运算符中直接或间接调用了自身，确保有终止条件，避免无限递归。


#### 区分拷贝构造 和 拷贝赋值运算符
- 拷贝构造函数（Copy Constructor）
  1. 用途：拷贝构造函数用于创建一个新对象作为现有对象的副本。它在以下情况下被调用：
     1. 当用一个已存在的对象直接初始化另一个新对象时，如 MyClass obj2(obj1)
     2. 当函数以值传递方式返回一个对象时，需要在调用者处创建一个副本。
     3. 当以值传递方式向函数传递对象时，形参需要被初始化为实参的副本。
  2. 调用时机：在新对象的生命周期开始时，作为构造过程的一部分。
  3. 语法：``MyClass(const MyClass& original);``

- 拷贝赋值运算符（Copy Assignment Operator）
  1. 用途：拷贝赋值运算符用于将一个已有对象的值赋给另一个已存在的对象。它在以下情况下被调用：
     1. 当一个对象通过赋值操作符=被赋予另一个同类型对象的值时，如 obj1 = obj2
     2. 在循环体或条件语句中改变对象的值时。
  2. 调用时机：在对象的生命周期内，当对象已经存在，需要更新其状态为另一个对象的状态时。
  3. 语法：``MyClass& operator=(const MyClass& other);``

- 区别总结
  - 本质差异：拷贝构造函数用于创建新对象，而拷贝赋值运算符用于更新已有对象。
  - 调用时刻：拷贝构造函数在对象创建时调用，拷贝赋值运算符在对象已经存在后调用。
  - 返回值：拷贝构造函数没有返回值，而拷贝赋值运算符通常返回对当前对象（即被赋值的对象）的引用，以便支持连续赋值。
  - 资源管理：二者都需要考虑深拷贝与浅拷贝的问题，尤其是当类中有动态分配的资源时。拷贝构造函数总是创建新对象，而拷贝赋值则需特别注意避免自我赋值导致的资源泄露。

### 移动构造函数
移动构造函数是在C++11中引入的一个特性，旨在优化资源的转移和管理，特别是在处理大型对象或资源密集型对象时，以提高性能和减少不必要的拷贝操作。移动构造函数的基本概念和用途如下：


#### 定义
移动构造函数是一种特殊的构造函数，它的目的是将一个即将被销毁的对象（通常是一个临时对象或者一个将要被重新赋值的对象）的资源“移动”到新创建的对象中，而不是进行复制。这通常涉及到指针或资源所有权的直接转移，而不需要复制底层数据，从而可以更高效地利用资源。

#### 语法
移动构造函数的声明类似于拷贝构造函数，不同之处在于它接受一个右值引用作为参数：
```cpp
class MyClass {
public:
    // 移动构造函数
    MyClass(MyClass&& other) noexcept {
        // 将other的资源移动到*this，可能包括交换或直接赋值指针
        data = other.data; // 假设data是一个指针成员
        other.data = nullptr; // 确保other不再拥有资源
    }

private:
    int* data; // 成员变量
};
```

#### 调用时机
移动构造函数在以下几种情况自动被调用：

1. 临时对象赋值：将一个临时对象直接赋给一个新对象，如 MyClass obj = MyClass();
2. 返回值优化：当函数返回一个局部对象时，可以移动该对象到调用方，避免拷贝。
3. 容器操作：STL容器（如std::vector）在内部调整大小或重新分配内存时，可能会使用移动构造函数来转移元素，以提高效率。

#### 为何重要
- 性能提升：移动构造函数避免了深拷贝，特别是在处理大型对象或复杂数据结构时，显著提高了程序性能。
- 资源管理：通过直接转移资源所有权，避免了资源的复制和潜在的泄露风险。
- 无成本移动：对于那些资源持有者（如智能指针），移动操作可以是“无成本”的，即几乎立即完成，因为只需要更改几个指针或计数器。

#### noexcept
通常，移动构造函数会被标记为noexcept，这告诉编译器此操作不会抛出异常，使得编译器能够在更多场合安全地使用移动语义，进一步优化性能。
![noexcept](../关键字与限定符/noexcept.md)

### 移动赋值运算符
移动赋值运算符是C++11引入的一种特殊成员函数，用于优化资源管理，尤其是在处理大型对象或资源密集型对象的赋值操作时。它通过转移而非复制资源来提高效率，减少不必要的深拷贝。以下是移动赋值运算符的详细讲解：

#### 定义
移动赋值运算符是一个重载的赋值运算符，其参数是一个右值引用，用于接收一个即将被销毁或不再需要的对象的资源。它的返回值通常是当前对象的左值引用，并且通常会标记为noexcept以表明不会抛出异常。
```cpp
class MyClass {
public:
    // 移动赋值运算符
    MyClass& operator=(MyClass&& other) noexcept {
        if (this != &other) {
            // 将other的资源转移到*this
            delete data; // 释放当前对象的资源（如果有）
            data = other.data; // 获取other的数据指针
            other.data = nullptr; // 确保other不再拥有资源
        }
        return *this; // 支持连续赋值
    }

private:
    int* data; // 成员变量，假设是一个指向动态分配内存的指针
};
```

#### 调用时机
移动赋值运算符在以下情况下被调用：
1. 对象赋值给一个即将被销毁的临时对象：如 MyClass obj; obj = MyClass();
2. STL容器中的元素重排：当容器（如std::vector）在内部调整大小或重新分配内存时，可能会使用移动赋值来转移元素。
3. 返回值优化：函数返回局部对象且被直接赋值给一个已存在对象时，可能触发移动赋值。

#### 目的与优势
- 性能优化：避免了昂贵的深拷贝操作，特别是对于大对象或含有动态分配资源的对象，极大地提高了程序效率。
- 资源管理：直接转移资源的所有权，避免了资源的复制和原对象资源的泄露。
- 减少内存占用：在对象生命周期结束前，其拥有的资源能够迅速有效地被其他对象接管和复用。

#### 与拷贝赋值的区别
尽管移动赋值和拷贝赋值看起来相似，但它们的核心区别在于对待源对象的方式：

- 拷贝赋值会创建源对象数据的副本，两个对象最终拥有独立的数据副本。
- 移动赋值则“窃取”源对象的数据或资源，源对象通常被置为某种无效状态，不再拥有这些资源。

#### noexcept
由于移动操作理应不抛出异常（除非资源移动过程中发生了异常情况，这是极少见的），所以通常将移动赋值运算符标记为noexcept。这允许编译器做出更多优化决策，例如在标准库容器调整大小时优先选择移动而非拷贝。
![noexcept](../关键字与限定符/noexcept.md)

#### 实现细节
- 自我赋值检查：尽管在移动赋值中自我赋值的可能性较低，但仍建议实施检查，以确保操作的健壮性。
- 资源清理：确保在转移资源前，先释放当前对象持有的资源（如果有的话）。
- 置空原对象：将源对象的相关指针或资源引用设置为nullptr或其他无效状态，防止悬空指针问题。

### 地址操作符
取地址操作符在C++中是一个非常基础且重要的运算符，主要用来获取对象或变量在内存中的地址。它有两种形式，分别是一般形式的取地址运算符&和用于类类型的取地址运算符重载。

#### 一般形式的取地址运算符
1. 符号与用法：取地址运算符是一个前置的单目运算符，表示为&。当你在变量或对象前面放置这个运算符时，它会返回该变量或对象在内存中的地址。
例如：
```cpp
int x = 10;
int* p = &x; // p 存储了变量x的内存地址
```

2. 类型：取地址运算符的结果类型是一个指向其操作数类型的指针。如果x是一个int类型，那么&x的结果类型就是int*。

3. 作用对象：它可以应用于任何具有内存地址的实体上，包括普通变量、数组名、函数名以及类的非静态成员等。

#### 类类型的取地址操作符重载
对于类类型，C++允许重载取地址运算符。这意味着你可以自定义当取某个类对象地址时的行为，虽然这通常只对指针或引用成员有意义。

1. 重载形式：重载取地址运算符使用operator&，通常作为类的成员函数实现。它没有参数，返回类型是一个指向该类类型的指针。
例如：
```cpp
class MyClass {
public:
    MyClass* operator&() {
        return this; // 返回当前对象的地址
    }
};
```

2. 何时重载：重载取地址操作符通常不是必需的，除非有特殊需求，比如管理资源或实现复杂的指针逻辑。大多数情况下，编译器提供的默认行为已经足够。

3. 注意事项：重载取地址运算符时需要谨慎，确保不破坏对象的逻辑一致性，特别是处理自定义的资源管理类时。

### 常量取地址操作符
在C++中，常量取地址操作符的概念主要与取地址操作符(&)结合const关键字一起讨论，尤其是在涉及类和对象的上下文中。当我们谈论“常量取地址操作符”，实际上是指获取一个常量对象或常量成员的地址。这里有几个关键点需要理解：

#### 常量对象与取地址
1. 常量对象：当一个对象被声明为常量（使用const关键字），意味着该对象的值在其生命周期内不应被修改。例如：
```cpp
const int x = 10;
```
这里，x是一个常量整数，其值不能被改变。

2. 取常量对象的地址：尽管不能修改常量对象的值，但我们可以获取其地址，并且这个地址可以被存储在一个指向常量的指针中。这样的指针被称为const指针，它只能用于读取数据，不能修改数据：
```cpp
const int* ptr = &x; // ptr 是指向常量整数的指针
```

#### 类中的常量成员取地址
对于类中的常量成员，情况类似：

1. 常量成员函数中的this指针：在常量成员函数（由const关键字后置成员函数声明）内部，this指针是一个指向常量对象的指针（const MyClass* const this）。这意味着成员函数不能修改对象的任何成员，但可以获取这些成员的地址，包括常量成员的地址。

2. 常量成员取地址：如果你有一个类，其中包含常量成员，你可以从常量对象实例中获取这些常量成员的地址。这通常在重载取地址操作符或在类的内部实现中有所体现。

#### 重载取地址操作符与const
- 常量重载版本：当重载取地址操作符(operator&)时，通常会提供两个版本：一个用于非const对象，另一个用于const对象。这样可以确保无论对象是否为常量，都能正确地获取其地址。
```cpp
MyClass* operator&() { return this; } // 非const版本
const MyClass* operator&() const { return this; } // const版本
```

- const成员函数的约束：在const成员函数中，只能调用const版本的取地址操作符，这保证了对象的常量性不被违反。

#### 总结
常量取地址操作符的核心在于理解如何与const关键字一起使用，以确保遵循C++的常量正确性规则。通过获取常量对象或常量成员的地址，我们可以安全地访问这些数据，而不破坏它们的不变性。在类的设计中，正确重载取地址操作符的const版本是实现这一目标的关键。

## 类与面向对象
![面向对象](../面向对象/面向对象.md)

### 继承和派生
1. 继承（Inheritance）可以理解为一个类从另一个类获取成员变量和成员函数的过程。
2. 在C++中，派生（Derive）和继承是一个概念，只是站的角度不同。继承是儿子接收父亲的产业，派生是父亲把产业传承给儿子。
>被继承的类称为父类或基类，继承的类称为子类或派生类。“子类”和“父类”通常放在一起称呼，“基类”和“派生类”通常放在一起称呼。
3. 派生类除了拥有基类的成员，还可以定义自己的新成员，以增强类的功能。
4. 以下是两种典型的使用继承的场景：
   1. 当你创建的新类与现有的类相似，只是多出若干成员变量或成员函数时，可以使用继承，这样不但会减少代码量，而且新类会拥有基类的所有功能。
   2. 当你需要创建多个类，它们拥有很多相似的成员变量或成员函数时，也可以使用继承。可以将这些类的共同成员提取出来，定义为基类，然后从基类继承，既可以节省代码，也方便后续修改成员。
```cpp
#include<iostream>
using namespace std;
//基类 Pelple
class People{
public:
    void setname(char *name);
    void setage(int age);
    char *getname();
    int getage();
private:
    char *m_name;
    int m_age;
};
void People::setname(char *name){ m_name = name; }
void People::setage(int age){ m_age = age; }
char* People::getname(){ return m_name; }
int People::getage(){ return m_age;}
//派生类 Student
class Student: public People{
public:
    void setscore(float score);
    float getscore();
private:
    float m_score;
};
void Student::setscore(float score){ m_score = score; }
float Student::getscore(){ return m_score; }
int main(){
    Student stu;
    stu.setname("小明");
    stu.setage(16);
    stu.setscore(95.5f);
    cout<<stu.getname()<<"的年龄是 "<<stu.getage()<<"，成绩是 "<<stu.getscore()<<endl;
    return 0;
}
```
本例中，People 是基类，Student 是派生类。Student 类继承了 People 类的成员，同时还新增了自己的成员变量 score 和成员函数 setscore()、getscore()。这些继承过来的成员，可以通过子类对象访问，就像自己的一样。

请认真观察代码第21行：
```cpp
class Student: public People
```
这就是声明派生类的语法。class 后面的“Student”是新声明的派生类，冒号后面的“People”是已经存在的基类。在“People”之前有一关键宇 public，用来表示是公有继承。

由此总结出继承的一般语法为：
```cpp
class 派生类名:［继承方式］ 基类名{
    派生类新增加的成员
};
```
继承方式包括 public（公有的）、private（私有的）和 protected（受保护的），此项是可选的，如果不写，那么默认为 private。我们将在下节详细讲解这些不同的继承方式。

#### 继承时的名字遮挡问题
如果派生类中的成员（包括成员变量和成员函数）和基类中的成员重名，那么就会遮蔽从基类继承过来的成员。所谓遮蔽，就是在派生类中使用该成员（包括在定义派生类时使用，也包括通过派生类对象访问该成员）时，实际上使用的是派生类新增的成员，而不是从基类继承来的。
```cpp
#include<iostream>
using namespace std;
//基类People
class People{
public:
    void show();
protected:
    char *m_name;
    int m_age;
};
void People::show(){
    cout<<"嗨，大家好，我叫"<<m_name<<"，今年"<<m_age<<"岁"<<endl;
}
//派生类Student
class Student: public People{
public:
    Student(char *name, int age, float score);
public:
    void show();  //遮蔽基类的show()
private:
    float m_score;
};
Student::Student(char *name, int age, float score){
    m_name = name;
    m_age = age;
    m_score = score;
}
void Student::show(){
    cout<<m_name<<"的年龄是"<<m_age<<"，成绩是"<<m_score<<endl;
}
int main(){
    Student stu("小明", 16, 90.5);
    //使用的是派生类新增的成员函数，而不是从基类继承的
    stu.show();
    //使用的是从基类继承来的成员函数
    stu.People::show();
    return 0;
}
```
- 本例中，基类 People 和派生类 Student 都定义了成员函数 show()，它们的名字一样，会造成遮蔽。第 37 行代码中，stu 是 Student 类的对象，默认使用 Student 类的 show() 函数。
- 但是，基类 People 中的 show() 函数仍然可以访问，不过要加上类名和域解析符，如第 39 行代码所示。

#### 基类和派生类的构造函数
1. 普通的成员函数
    - 基类的成员函数可以被继承，可以通过派生类的对象访问
2. 类的构造函数不能被继承
    - 构造函数不能被继承是有道理的，因为即使继承了，它的名字和派生类的名字也不一样，不能成为派生类的构造函数，当然更不能成为普通的成员函数。
3. 在设计派生类时，对继承过来的成员变量的初始化工作也要由派生类的构造函数完成，但是大部分基类都有 private 属性的成员变量，它们在派生类中无法访问，更不能使用派生类的构造函数来初始化。
>这种矛盾在C++继承中是普遍存在的，解决这个问题的思路是：在派生类的构造函数中调用基类的构造函数。

下面的例子展示了如何在派生类的构造函数中调用基类的构造函数：
```cpp
#include<iostream>
using namespace std;
//基类People
class People{
protected:
    char *m_name;
    int m_age;
public:
    People(char*, int);
};
People::People(char *name, int age): m_name(name), m_age(age){}
//派生类Student
class Student: public People{
private:
    float m_score;
public:
    Student(char *name, int age, float score);
    void display();
};
//People(name, age)就是调用基类的构造函数
Student::Student(char *name, int age, float score): People(name, age), m_score(score){ }
void Student::display(){
    cout<<m_name<<"的年龄是"<<m_age<<"，成绩是"<<m_score<<"。"<<endl;
}
int main(){
    Student stu("小明", 16, 90.5);
    stu.display();
    return 0;
}
```
请注意第 23 行代码：
```cpp
Student::Student(char *name, int age, float score): People(name, age), m_score(score){ }
```
``People(name, age)``就是调用基类的构造函数，并将 name 和 age 作为实参传递给它，``m_score(score)``是派生类的参数初始化表，它们之间以逗号``,``隔开。
也可以将基类构造函数的调用放在参数初始化表后面：
```cpp
Student::Student(char *name, int age, float score): m_score(score), People(name, age){ }
```
但是不管它们的顺序如何，派生类构造函数总是先调用基类构造函数再执行其他代码（包括参数初始化表以及函数体中的代码），总体上看和下面的形式类似：
```cpp
Student::Student(char *name, int age, float score){
    People(name, age);
    m_score = score;
}
```
当然这段代码只是为了方便大家理解，实际上这样写是错误的，因为基类构造函数不会被继承，不能当做普通的成员函数来调用。换句话说，只能将基类构造函数的调用放在函数头部，不能放在函数体中。
另外，函数头部是对基类构造函数的调用，而不是声明，所以括号里的参数是实参，它们不但可以是派生类构造函数参数列表中的参数，还可以是局部变量、常量等，例如：
```cpp
Student::Student(char *name, int age, float score): People("小明", 16), m_score(score){ }
```
4. 构造函数的调用顺序
- 构造函数的调用顺序是按照继承的层次自顶向下、从基类再到派生类的。
- 派生类构造函数中只能调用直接基类的构造函数，不能调用间接基类的。
    - C++ 这样规定是有道理的，因为我们在 C 中调用了 B 的构造函数，B 又调用了 A 的构造函数，相当于 C 间接地（或者说隐式地）调用了 A 的构造函数，如果再在 C 中显式地调用 A 的构造函数，那么 A 的构造函数就被调用了两次，相应地，初始化工作也做了两次，这不仅是多余的，还会浪费CPU时间以及内存，毫无益处，所以 C++ 禁止在 C 中显式地调用 A 的构造函数。 

5. 基类构造函数调用规则
事实上，通过派生类创建对象时必须要调用基类的构造函数，这是语法规定。换句话说，定义派生类构造函数时最好指明基类构造函数；如果不指明，就调用基类的默认构造函数（不带参数的构造函数）；如果没有默认构造函数，那么编译失败。
```cpp
#include <iostream>
using namespace std;
//基类People
class People{
public:
    People();  //基类默认构造函数
    People(char *name, int age);
protected:
    char *m_name;
    int m_age;
};
People::People(): m_name("xxx"), m_age(0){ } // 默认构造函数
People::People(char *name, int age): m_name(name), m_age(age){} // 两个参数的构造函数
//派生类Student
class Student: public People{
public:
    Student();
    Student(char*, int, float);
public:
    void display();
private:
    float m_score;
};
Student::Student(): m_score(0.0){ }  //派生类默认构造函数
Student::Student(char *name, int age, float score): People(name, age), m_score(score){ }    
void Student::display(){
    cout<<m_name<<"的年龄是"<<m_age<<"，成绩是"<<m_score<<"。"<<endl;
}
int main(){
    Student stu1;
    stu1.display();
    Student stu2("小明", 16, 90.5);
    stu2.display();
    return 0;
}
```
创建对象 stu1 时，执行派生类的构造函数``Student::Student()``，它并没有指明要调用基类的哪一个构造函数，从运行结果可以很明显地看出来，系统默认调用了不带参数的构造函数，也就是``People::People()``。

创建对象 stu2 时，执行派生类的构造函数``Student::Student(char *name, int age, float score)``,它指明了基类的构造函数。

在第 27 行代码中，如果将``People(name, age)``去掉，也会调用默认构造函数，

如果将基类 People 中不带参数的构造函数删除，那么会发生编译错误，因为创建对象 stu1 时需要调用 People 类的默认构造函数， 而 People 类中已经显式定义了构造函数，编译器不会再生成默认的构造函数。

#### 基类和派生类的析构函数
和构造函数类似，析构函数也不能被继承。与构造函数不同的是，在派生类的析构函数中不用显式地调用基类的析构函数，因为每个类只有一个析构函数，编译器知道如何选择，无需程序员干涉。

另外析构函数的执行顺序和构造函数的执行顺序也刚好相反：
- 创建派生类对象时，构造函数的执行顺序和继承顺序相同，即先执行基类构造函数，再执行派生类构造函数。
- 而销毁派生类对象时，析构函数的执行顺序和继承顺序相反，即先执行派生类析构函数，再执行基类析构函数。
```cpp
#include <iostream>
using namespace std;
class A{
public:
    A(){cout<<"A constructor"<<endl;}
    ~A(){cout<<"A destructor"<<endl;}
};
class B: public A{
public:
    B(){cout<<"B constructor"<<endl;}
    ~B(){cout<<"B destructor"<<endl;}
};
class C: public B{
public:
    C(){cout<<"C constructor"<<endl;}
    ~C(){cout<<"C destructor"<<endl;}
};
int main(){
    C test;
    return 0;
}

运行结果：
A constructor
B constructor
C constructor
C destructor
B destructor
A destructor
```

#### 多继承（多重继承）
在前面的例子中，派生类都只有一个基类，称为单继承（Single Inheritance）。除此之外，C++也支持多继承（Multiple Inheritance），即一个派生类可以有两个或多个基类。
>多继承容易让代码逻辑复杂、思路混乱，一直备受争议，中小型项目中较少使用，后来的 Java、C#、PHP 等干脆取消了多继承。

多继承的语法也很简单，将多个基类用逗号隔开即可。例如已声明了类A、类B和类C，那么可以这样来声明派生类D：
```cpp
class D: public A, private B, protected C{
    //类D新增加的成员
}
```
D 是多继承形式的派生类，它以公有的方式继承 A 类，以私有的方式继承 B 类，以保护的方式继承 C 类。D 根据不同的继承方式获取 A、B、C 中的成员，确定它们在派生类中的访问权限。

##### 多继承下的构造函数
多继承形式下的构造函数和单继承形式基本相同，只是要在派生类的构造函数中调用多个基类的构造函数。以上面的 A、B、C、D 类为例，D 类构造函数的写法为：
```cpp
D(形参列表): A(实参列表), B(实参列表), C(实参列表){
    //其他操作
}
```
基类构造函数的调用顺序和和它们在派生类构造函数中出现的顺序无关，而是和声明派生类时基类出现的顺序相同。仍然以上面的 A、B、C、D 类为例，即使将 D 类构造函数写作下面的形式：
```cpp
D(形参列表): B(实参列表), C(实参列表), A(实参列表){
    //其他操作
}
```
那么也是先调用 A 类的构造函数，再调用 B 类构造函数，最后调用 C 类构造函数。
下面是一个多继承的实例：
```cpp
#include <iostream>
using namespace std;
//基类
class BaseA{
public:
    BaseA(int a, int b);
    ~BaseA();
protected:
    int m_a;
    int m_b;
};
BaseA::BaseA(int a, int b): m_a(a), m_b(b){
    cout<<"BaseA constructor"<<endl;
}
BaseA::~BaseA(){
    cout<<"BaseA destructor"<<endl;
}
//基类
class BaseB{
public:
    BaseB(int c, int d);
    ~BaseB();
protected:
    int m_c;
    int m_d;
};
BaseB::BaseB(int c, int d): m_c(c), m_d(d){
    cout<<"BaseB constructor"<<endl;
}
BaseB::~BaseB(){
    cout<<"BaseB destructor"<<endl;
}
//派生类
class Derived: public BaseA, public BaseB{
public:
    Derived(int a, int b, int c, int d, int e);
    ~Derived();
public:
    void show();
private:
    int m_e;
};
Derived::Derived(int a, int b, int c, int d, int e): BaseA(a, b), BaseB(c, d), m_e(e){
    cout<<"Derived constructor"<<endl;
}
Derived::~Derived(){
    cout<<"Derived destructor"<<endl;
}
void Derived::show(){
    cout<<m_a<<", "<<m_b<<", "<<m_c<<", "<<m_d<<", "<<m_e<<endl;
}
int main(){
    Derived obj(1, 2, 3, 4, 5);
    obj.show();
    return 0;
}
运行结果：
BaseA constructor
BaseB constructor
Derived constructor
1, 2, 3, 4, 5
Derived destructor
BaseB destructor
BaseA destructor
```
从运行结果中还可以发现，多继承形式下析构函数的执行顺序和构造函数的执行顺序相反。

##### 命名冲突
当两个或多个基类中有同名的成员时，如果直接访问该成员，就会产生命名冲突，编译器不知道使用哪个基类的成员。这个时候需要在成员名字前面加上类名和域解析符::，以显式地指明到底使用哪个类的成员，消除二义性。

修改上面的代码，为 BaseA 和 BaseB 类添加 show() 函数，并将 Derived 类的 show() 函数更名为 display()：
```c++
#include <iostream>
using namespace std;
//基类
class BaseA{
public:
    BaseA(int a, int b);
    ~BaseA();
public:
    void show();
protected:
    int m_a;
    int m_b;
};
BaseA::BaseA(int a, int b): m_a(a), m_b(b){
    cout<<"BaseA constructor"<<endl;
}
BaseA::~BaseA(){
    cout<<"BaseA destructor"<<endl;
}
void BaseA::show(){
    cout<<"m_a = "<<m_a<<endl;
    cout<<"m_b = "<<m_b<<endl;
}
//基类
class BaseB{
public:
    BaseB(int c, int d);
    ~BaseB();
    void show();
protected:
    int m_c;
    int m_d;
};
BaseB::BaseB(int c, int d): m_c(c), m_d(d){
    cout<<"BaseB constructor"<<endl;
}
BaseB::~BaseB(){
    cout<<"BaseB destructor"<<endl;
}
void BaseB::show(){
    cout<<"m_c = "<<m_c<<endl;
    cout<<"m_d = "<<m_d<<endl;
}
//派生类
class Derived: public BaseA, public BaseB{
public:
    Derived(int a, int b, int c, int d, int e);
    ~Derived();
public:
    void display();
private:
    int m_e;
};
Derived::Derived(int a, int b, int c, int d, int e): BaseA(a, b), BaseB(c, d), m_e(e){
    cout<<"Derived constructor"<<endl;
}
Derived::~Derived(){
    cout<<"Derived destructor"<<endl;
}
void Derived::display(){
    BaseA::show();  //调用BaseA类的show()函数
    BaseB::show();  //调用BaseB类的show()函数
    cout<<"m_e = "<<m_e<<endl;
}
int main(){
    Derived obj(1, 2, 3, 4, 5);
    obj.display();
    return 0;
}
请读者注意第 64、65 行代码，我们显式的指明了要调用哪个基类的 show() 函数。
```

##### 多继承中的内存模型
C++语言通过引入"虚函数表"的形式来支持多态特性，并且为了解决多重继承中的冗余和二义性问题又引入了虚继承，这使得C++类的内存模型呈现出一定的复杂性。

###### 无虚函数时多重继承的内存模型
C++要求所有实例化的对象都要有相应的内存地址，因此对一个不包含任何成员变量、成员函数的空类的实例会占用一个字节的内存空间。而非空类则按照以下规则安排其成员在内存中的排列顺序：
- 成员函数不占用内存空间
- 同一个类（不包括父类）中的成员变量在内存中按照在类中的声明次序依次排列，排列顺序与访问权限、变量名没有关系
- 继承自父类的成员变量排在当前类所有成员变量之前
- 继承自多个父类的成员变量按照类继承列表中的声明顺序依次排列每个父类中的成员变量

根据这些规则，定义下面这些类并限制他们间的继承关系，我们可以很容易的得出KTestClass类任一实例的内存模型：
```cpp
class KTopClass
{
public:
    KTopClass() : m_iTopVar(0)
    {
        cout << "KTopClass constructed." << endl;
    }
private:
    int m_iTopVar;
};

class KLBaseClass : public KTopClass
{
public:
    KLBaseClass() : m_iLVar(0)
    {
        cout << "KLBaseClass constructed." << endl;
    }
private:
    int m_iLVar;
};

class KRBaseClass
{
public:
    KRBaseClass() : m_iRVar(0)
    {
        cout << "KRBaseClass constructed." << endl;
    }
private:
    int m_iRVar;
};

class KTestClass : public KLBaseClass, public KRBaseClass
{
private:
    int m_iVar1;
public:
    KTestClass() : m_iVar1(0), m_iVar2(0) { cout << "KTestClass constructed." << endl; }
    int m_iVar2;
};
```
![多继承中的内存模型](03虚函数表2.png)

###### 存在虚函数时多重继承的内存模型
为了支持多态特性，C++引用虚函数表，父类中的所有虚函数均列在虚函数表中（按照声明顺序，纯虚函数也不例外），子类首先继承父类的虚函数表（非虚继承），如果重写了某个虚函数，那么就用自己所重写的函数地址去覆盖继承下来的虚函数表中的对应虚函数的旧地址，这个旧地址可能是父类新定义的虚函数的地址，也可能是父类覆盖了父类的父类中的虚函数后的“新地址”，之后再将当前子类所新定义的虚函数依次加在父类虚函数表的后面。如果子类没有重写父类的虚函数，那么直接继承父类的虚函数表，并将当前子类所新定义的虚函数依次加在父类虚函数表的后面。处理完虚函数表后，然后再依次排列父类的成员变量。重复这个过程直到所有父类按照继承顺序依次处理完毕，然后再排列子类的成员变量，成员变量的排列规则同上一节所述。需要注意的是如果是多继承，那么子类的虚函数是接在第一个被继承的有虚函数的父类虚函数表后面的。
举个较为复杂的例子来理解：
```cpp
class KTopClass
{
public:
    KTopClass() : m_iTopVar(0)
    {
        cout << "KTopClass constructed." << endl;
    }
    virtual void virtual_top_test(){ cout << "KTopClass::virtual_top_test." << endl; }
    virtual void pure_virtual_top_test() = 0;
private:
    int m_iTopVar;
};

class KLBaseClass : public KTopClass
{
public:
    KLBaseClass() : m_iLVar(0)
    {
        cout << "KLBaseClass constructed." << endl;
    }
    virtual void virtual_lbase_test(){ cout << "KLBaseClass::virtual_lbase_test." << endl; }
    void pure_virtual_top_test()
    {
        cout << "KLBaseClass::pure_virtual_top_test." << endl;
    }
private:
    int m_iLVar;
};

class KRBaseClass
{
public:
    KRBaseClass() : m_iRVar(0)
    {
        cout << "KRBaseClass constructed." << endl;
    }
    virtual void virtual_rbase_test(){ cout << "KRBaseClass::virtual_rbase_test." << endl; }
private:
    int m_iRVar;
};

class KTestClass : public KLBaseClass, public KRBaseClass
{
private:
    int m_iVar1;
public:
    KTestClass() : m_iVar1(0), m_iVar2(0) { cout << "KTestClass constructed." << endl; }
    void virtual_lbase_test(){ cout << "KTestClass::virtual_lbase_test." << endl; }
    int m_iVar2;
};
```
内存模型如下：
![存在虚函数时多重继承的内存模型](03虚函数表3.png)
这个例子中一共有两张虚表，注意这里所说的虚表实际上是指向一个数组的指针，因此每一张虚表占用四个字节。
说明：
- 每个对象的内存空间的第一个空间指向虚表(如果有的话)
- 每个类如果有虚函数，那么就有自己的虚函数表，简称虚表
继承顺序：
- 子类继承父类的虚函数表（非虚继承）
- 如果重写了某个虚函数，那么就用自己所重写的函数地址去覆盖继承下来的虚函数表中的对应虚函数的旧地址，这个旧地址可能是父类新定义的虚函数的地址，也可能是父类覆盖了父类的父类中的虚函数后的“新地址”
- 将当前子类所新定义的虚函数依次加在父类虚函数表的后面
- 如果子类没有重写父类的虚函数，那么直接继承父类的虚函数表，并将当前子类所新定义的虚函数依次加在父类虚函数表的后面
- 处理完虚函数表后，然后再依次排列父类的成员变量
- 重复这个过程直到所有父类按照继承顺序依次处理完毕
- 然后再排列子类的成员变量
- 如果是多继承，那么子类的虚函数是接在第一个被继承的有虚函数的父类虚函数表后面的。

###### 存在虚函数及虚继承时多重继承的内存模型
存在虚继承的情况下，类实例的内存模型与没有虚继承的情况基本是相同的，但是要注意一个原则，即被虚继承的父类在子类中是共享的，而非虚继承的父类在每个子类中都有一份。如果要用一个例子来说明，我们可以先将上一节中的KRBaseClass类的声明修改一下，使其也继承自KTopClass类，其余部分保持不变，KRBaseClass 部分修改如下：
```cpp
class KRBaseClass : public KTopClass
{
public:
    KRBaseClass() : m_iRVar(0)
    {
        cout << "KRBaseClass constructed." << endl;
    }
    virtual void virtual_rbase_test(){ cout << "KRBaseClass::virtual_rbase_test." << endl; }
    void pure_virtual_top_test()
    {
        cout << "KRBaseClass::pure_virtual_top_test." << endl;
    }
private:
    int m_iRVar;
};
```
这时的内存模型就变为：
![存在虚函数及虚继承时多重继承的内存模型](03虚函数表4.png)
可见在KTestClass的实例中有两份KTopClass，这就是所谓的非虚继承的父类在每个子类中都有一份，这造成了一定的冗余和调用时的二义性，为了消除这种二义性，C++引入了虚继承，被虚继承的父类在子类中是共享的。可以设计如下的继承结构来说明这个问题：
```cpp
class B { /* ... */ };
class X : virtual public B { /* ... */ };
class Y : virtual public B { /* ... */ };
class Z : public B { /* ... */ };
class AA : public X, public Y, public Z { /* ... */ };
```
![继承关系](03虚函数表5.png)
在实际的AA的实例中是有两份B的子对象的，其中一份由X、Y子对象共享，因为它们是虚继承自B类的，而另一份是来自于Z子对象的。
我们还是回到最开始的例子中，我们将KLBaseClass类和KRBaseClass均改为虚继承自KTopClass类：
```cpp
class KTopClass
{
public:
    KTopClass() : m_iTopVar(0)
    {
        cout << "KTopClass constructed." << endl;
    }
    virtual void virtual_top_test(){ cout << "KTopClass::virtual_top_test." << endl; }
    virtual void pure_virtual_top_test() = 0;
private:
    int m_iTopVar;
};

class KLBaseClass : virtual public KTopClass
{
public:
    KLBaseClass() : m_iLVar(0)
    {
        cout << "KLBaseClass constructed." << endl;
    }
    virtual void virtual_lbase_test(){ cout << "KLBaseClass::virtual_lbase_test." << endl; }
    void virtual_top_test(){ cout << "KLBaseClass::virtual_top_test." << endl; }
private:
    int m_iLVar;
};

class KRBaseClass : virtual public KTopClass
{
public:
    KRBaseClass() : m_iRVar(0)
    {
        cout << "KRBaseClass constructed." << endl;
    }
    virtual void virtual_rbase_test(){ cout << "KRBaseClass::virtual_rbase_test." << endl; }
private:
    int m_iRVar;
};

class KTestClass : public KLBaseClass, public KRBaseClass
{
private:
    int m_iVar1;
public:
    KTestClass() : m_iVar1(0), m_iVar2(0) { cout << "KTestClass constructed." << endl; }
    void virtual_lbase_test(){ cout << "KTestClass::virtual_lbase_test." << endl; }
    void pure_virtual_top_test()
    {
        cout << "KTestClass::pure_virtual_top_test." << endl;
    }
    int m_iVar2;
};
```
此时KTestClass实例的内存模型变成了如下形式，即所有被虚继承的父类对应的子对象被统一放在了最后，实际上，不同编译器对放置位置的处理稍有不同，有的是将虚继承的子对象放在了子对象所有成员变量的最后面，有的则是放在了所有父类子对象之后，子类子对象之前。
![](03虚函数表6.png)
到这里，很容易就会产生一个疑问，如果KLBaseClass和KRBaseClass中只有KRBaseClass是虚继承自KTopClass呢，实际上这种情况下，KRBaseClass所对应的那一份KTopClass子对象被放在最后，而KLBaseClass那一份仍按原来的规则存放。

总结
本文分别分析了有无虚函数以及虚继承情况下类对象的内存模型，从底层对C++的多态特性的实现进行了解释，但需要注意的是，实际中不同编译器下对内存模型的实现细节是稍有不同的。


### C++三种继承方式
C++继承的一般语法为：
class 派生类名:［继承方式］ 基类名{
    派生类新增加的成员
};
继承方式限定了基类成员在派生类中的访问权限，包括 public（公有的）、private（私有的）和 protected（受保护的）。此项是可选项，如果不写，默认为 private（成员变量和成员函数默认也是 private）。

现在我们知道，public、protected、private 三个关键字除了可以修饰类的成员，还可以指定继承方式。

#### public、protected、private 修饰类的成员
类成员的访问权限由高到低依次为 public --> protected --> private
1. public:成员可以通过对象来访问
2. protected:protected 成员和 private 成员类似，也不能通过对象访问。但是当存在继承关系时，protected 和 private 就不一样了：基类中的 protected 成员可以在派生类中使用，而基类中的 private 成员不能在派生类中使用。
3. private:成员不能通过对象访问

#### public、protected、private 指定继承方式
不同的继承方式会影响基类成员在派生类中的访问权限。

##### public继承方式
基类中所有 public 成员在派生类中为 public 属性；
基类中所有 protected 成员在派生类中为 protected 属性；
基类中所有 private 成员在派生类中不能使用。

##### protected继承方式
基类中的所有 public 成员在派生类中为 protected 属性；
基类中的所有 protected 成员在派生类中为 protected 属性；
基类中的所有 private 成员在派生类中不能使用。

##### private继承方式
基类中的所有 public 成员在派生类中均为 private 属性；
基类中的所有 protected 成员在派生类中均为 private 属性；
基类中的所有 private 成员在派生类中不能使用。

##### 三种继承方式小节
通过上面的分析可以发现：
1. 基类成员在派生类中的访问权限不得高于继承方式中指定的权限。例如，当继承方式为 protected 时，那么基类成员在派生类中的访问权限最高也为 protected，高于 protected 的会降级为 protected，但低于 protected 不会升级。再如，当继承方式为 public 时，那么基类成员在派生类中的访问权限将保持不变。
也就是说，继承方式中的 public、protected、private 是用来指明基类成员在派生类中的最高访问权限的。
2. 不管继承方式如何，基类中的 private 成员在派生类中始终不能使用（不能在派生类的成员函数中访问或调用）。
3. 如果希望基类的成员能够被派生类继承并且毫无障碍地使用，那么这些成员只能声明为 public 或 protected；只有那些不希望在派生类中使用的成员才声明为 private。
4. 如果希望基类的成员既不向外暴露（不能通过对象访问），还能在派生类中使用，那么只能声明为 protected。
- 注意，我们这里说的是基类的 private 成员不能在派生类中使用，并没有说基类的 private 成员不能被继承。实际上，基类的 private 成员是能够被继承的，并且（成员变量）会占用派生类对象的内存，它只是在派生类中不可见，导致无法使用罢了。private 成员的这种特性，能够很好的对派生类隐藏基类的实现，以体现面向对象的封装性。
![不同继承方式对不同属性的成员的影响结果](03继承方式.png)
>由于 private 和 protected 继承方式会改变基类成员在派生类中的访问权限，导致继承关系复杂，所以实际开发中我们一般使用 public。
```c++
#include<iostream>
using namespace std;
//基类People
class People{
public:
    void setname(char *name);
    void setage(int age);
    void sethobby(char *hobby);
    char *gethobby();
protected:
    char *m_name;
    int m_age;
private:
    char *m_hobby;
};
void People::setname(char *name){ m_name = name; }
void People::setage(int age){ m_age = age; }
void People::sethobby(char *hobby){ m_hobby = hobby; }
char *People::gethobby(){ return m_hobby; }
//派生类Student
class Student: public People{
public:
    void setscore(float score);
protected:
    float m_score;
};
void Student::setscore(float score){ m_score = score; }
//派生类Pupil
class Pupil: public Student{
public:
    void setranking(int ranking);
    void display();
private:
    int m_ranking;
};
void Pupil::setranking(int ranking){ m_ranking = ranking; }
void Pupil::display(){
    cout<<m_name<<"的年龄是"<<m_age<<"，考试成绩为"<<m_score<<"分，班级排名第"<<m_ranking<<"，TA喜欢"<<gethobby()<<"。"<<endl;
}
int main(){
    Pupil pup;
    pup.setname("小明");
    pup.setage(15);
    pup.setscore(92.5f);
    pup.setranking(4);
    pup.sethobby("乒乓球");
    pup.display();
    return 0;
}
```
这是一个多级继承的例子，Student 继承自 People，Pupil 又继承自 Student，它们的继承关系为 People --> Student --> Pupil。Pupil 是最终的派生类，它拥有基类的 m_name、m_age、m_score、m_hobby 成员变量以及 setname()、setage()、sethobby()、gethobby()、setscore() 成员函数。

注意，在派生类 Pupil 的成员函数 display() 中，我们借助基类的 public 成员函数 gethobby() 来访问基类的 private 成员变量 m_hobby，因为 m_hobby 是 private 属性的，在派生类中不可见，所以只能借助基类的 public 成员函数 sethobby()、gethobby() 来访问。

- 在派生类中访问基类 private 成员的唯一方法就是借助基类的非 private 成员函数，如果基类没有非 private 成员函数，那么该成员在派生类中将无法访问。

##### using 改变基类成员访问权限
使用 `using` 关键字可以改变基类成员在派生类中的访问权限，例如将 public 改为 private、将 protected 改为 public。
- using 放在相应的区域，将权限改为对应区域的权限
- using 类名::类成员;
注意：using 只能改变基类中 public 和 protected 成员的访问权限，不能改变 private 成员的访问权限，因为基类中 private 成员在派生类中是不可见的，根本不能使用，所以基类中的 private 成员在派生类中无论如何都不能访问。
```c++
#include<iostream>
using namespace std;
//基类People
class People {
public:
    void show();
protected:
    char *m_name;
    int m_age;
};
void People::show() {
    cout << m_name << "的年龄是" << m_age << endl;
}
//派生类Student
class Student : public People {
public:
    void learning();
public:
    using People::m_name;  //将protected改为public
    using People::m_age;   //将protected改为public
    float m_score;
private:
    using People::show;    //将public改为private
};
void Student::learning() {
    cout << "我是" << m_name << "，今年" << m_age << "岁，这次考了" << m_score << "分！" << endl;
}
int main() {
    Student stu;
    stu.m_name = "小明";
    stu.m_age = 16;
    stu.m_score = 99.5f;
    stu.show();  //compile error
    stu.learning();
    return 0;
}
```
代码中首先定义了基类 People，它包含两个 protected 属性的成员变量和一个 public 属性的成员函数。定义 Student 类时采用 public 继承方式，People 类中的成员在 Student 类中的访问权限默认是不变的。

不过，我们使用 using 改变了它们的默认访问权限，如代码第 21~25 行所示，将 show() 函数修改为 private 属性的，是降低访问权限，将 name、age 变量修改为 public 属性的，是提高访问权限。

因为 show() 函数是 private 属性的，所以代码第 36 行会报错。把该行注释掉，程序输出结果为：
我是小明，今年16岁，这次考了99.5分！

#### 基类成员函数和派生类成员函数不构成重载
基类成员和派生类成员的名字一样时会造成遮蔽，这句话对于成员变量很好理解，对于成员函数要引起注意，不管函数的参数如何，只要名字一样就会造成遮蔽。换句话说，基类成员函数和派生类成员函数不会构成重载，==如果派生类有同名函数，那么就会遮蔽基类中的所有同名函数，不管它们的参数是否一样。==
- 只要重名就会遮蔽
```c++
#include<iostream>
using namespace std;
//基类Base
class Base{
public:
    void func();
    void func(int);
};
void Base::func(){ cout<<"Base::func()"<<endl; }
void Base::func(int a){ cout<<"Base::func(int)"<<endl; }
//派生类Derived
class Derived: public Base{
public:
    void func(char *);
    void func(bool);
};
void Derived::func(char *str){ cout<<"Derived::func(char *)"<<endl; }
void Derived::func(bool is){ cout<<"Derived::func(bool)"<<endl; }
int main(){
    Derived d;
    d.func("c.biancheng.net");
    d.func(true);
    d.func();  //compile error
    d.func(10);  //compile error
    d.Base::func();
    d.Base::func(100);
    return 0;
}
```
本例中，Base 类的func()、func(int)和 Derived 类的func(char *)、func(bool)四个成员函数的名字相同，参数列表不同，它们看似构成了重载，能够通过对象 d 访问所有的函数，实则不然，Derive 类的 func 遮蔽了 Base 类的 func，导致第 26、27 行代码没有匹配的函数，所以调用失败。
如果说有重载关系，那么也是 Base 类的两个 func 构成重载，而 Derive 类的两个 func 构成另外的重载。

#### C++类继承时的作用域嵌套，破解C++继承的一切秘密
类其实也是一种作用域，每个类都会定义它自己的作用域，在这个作用域内我们再定义类的成员。当存在继承关系时，派生类的作用域嵌套在基类的作用域之内，如果一个名字在派生类的作用域内无法找到，编译器会继续到外层的基类作用域中查找该名字的定义。
- 作用域能够彼此包含
- 内层作用域(inner scope):被包含（或者说被嵌套）的作用域
- 外层作用域(outer scope):包含着别的作用域的作用域。
一旦在外层作用域中声明（或者定义）了某个名字，那么它所嵌套着的所有内层作用域中都能访问这个名字。同时，允许在内层作用域中重新定义外层作用域中已有的名字。

假设 Base 是基类，Derived 是派生类，那么它们的作用域的嵌套关系如下图所示
![作用域嵌套](01作用域嵌套.jpg)
派生类的作用域位于基类作用域之内这一事实可能有点出人意料，毕竟在我们的代码中派生类和基类的定义是相互分离的。不过也恰恰因为类作用域有这种继承嵌套的关系，所以派生类才能像使用自己的成员一样来使用基类的成员。
```c++
#include<iostream>
using namespace std;
class A{
public:
    void func();
public:
    int n;
};
void A::func(){ cout<<"c.biancheng.net"<<endl; }
class B: public A{
public:
    int n;
    int m;
};
class C: public B{
public:
    int n;
    int x;
};
int main(){
    C obj;
    obj.n;
    obj.func();
    cout<<sizeof(C)<<endl;
    return 0;
}
```
本例中，B 继承自 A，C继承自 B，它们作用域的嵌套关系如下图所示：
![作用域嵌套1](01作用域嵌套1.jpg)
- obj 是 C 类的对象，通过 obj 访问成员变量 n 时，在 C 类的作用域中就能够找到了 n 这个名字。虽然 A 类和 B 类都有名字 n，但编译器不会到它们的作用域中查找，所以是不可见的，也即派生类中的 n 遮蔽了基类中的 n。
- 通过 obj 访问成员函数 func() 时，在 C 类的作用域中没有找到 func 这个名字，编译器继续到 B 类的作用域（外层作用域）中查找，仍然没有找到，再继续到 A 类的作用域中查找，结果就发现了 func 这个名字，于是查找结束，编译器决定调用 A 类作用域中的 func() 函数。
- 这个过程叫做名字==查找（name lookup）==，也就是在作用域链中寻找与所用名字最匹配的声明（或定义）的过程。

#### 借助指针突破访问权限的限制，访问private、protected属性的成员变量
正常情况下，我们没有办法通过对象访问，protected 和 private 类变量，但是借助指针，我们依然可以实现访问所有变量，只要我们拿到 对象的收地址，再根据数据类型推导指针地址变化长度，就可以实现突破限制访问protected 和 private 类变量。
PS:要注意的是，在成员边两种含有char类型变量时，由于内存对齐的存在，我们不能只加上数据的长度
```cpp
sizeof(char)
```
而是要增加 4 也就是
```cpp
sizeof(int)
```
class A 的内存结构模型如下：
![class A的内存结构模型](03classA.png)
可以看到 系统自动为char类型的m_b多分配了3个字节占位，这就是内存对齐，这样可以更快速的寻址后面的数据；
class B 的内存结构模型如下：
![class B 的内存结构模型](03classB.png)
在这里又有了变化，对于char类型的m__bb还是多分配了3个字节占位，对于int类型的m_dd则是多了4个字节占位（也许是为了和m_cc保持一致）
当增加在class B 后面增加char 类型的m_ee 后内存模型会变成下面的样子，原本m_dd后面的4个占位字符，又分配给了m_ee
B的大小却没有发生变化 还是 24；
![class B更改后的内存结构模型](03classB1.png)
请看下面的代码：
访问第三个变量时，要加上第一个和第二个数据所占字节数，但是并不是sizeof(int)+sizeof(char),而是sizeof(int)+sizeof(int)
```cpp
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<string>
using namespace std;
 
class A {
public:
	A(int a, char b, float c);
private:
	int m_a;
	char m_b;
	float m_c;
};
A::A(int a, char b, float c) : m_a(a), m_b(b), m_c(c) { }
void test01() {
	A obj(10, '@', 30.5f);
	//int a = obj.m_a;  //Compile Error
	int x = *(int*)(int)&obj;//访问第一个变量
	char y = *((char*)((int)&obj + sizeof(int)));//访问第二个变量，将第一个变量的地址转换为int格式，+第1个数据的长度sizeof(int)
	float z = *((float*)((int)&obj + sizeof(int)+ sizeof(int)));//访问第三个变量，将第一个变量的地址转换为int格式，+第1个数据的长度sizeof(int)
	                                                            //+第二个数据长度sizeof(int)(之所以不是sizeof(char),是因为内存对齐）
	cout << x << endl;
	cout << y << endl;
	cout << z << endl;
	cout << endl;
 
	A *p = new A(40, 'A', 60.8f);
	//int b = p->m_b;  //Compile Error
	x = *(int*)(int)p;
	y = *((char*)((int)p + sizeof(int)));
	z = *((float*)((int)p + sizeof(int) + sizeof(int)));
	cout << x << endl;
	cout << y << endl;
	cout << z << endl;
}
class B 
{
public:
	B(int aa, char bb, double cc,int dd);
private:
	int m_aa;
	char m_bb;
	double m_cc;
	int m_dd;
};
B::B(int aa, char bb, double cc,int dd) : m_aa(aa), m_bb(bb), m_cc(cc),m_dd(dd) { }
 
void test02()
{
	B objb(11, 'C', 99.999,66);
	int x = *(int*)(int)&objb;//访问第一个变量
	char y = *((char*)((int)&objb + sizeof(int)));//访问第二个变量
	double z = *((double*)((int)&objb + sizeof(int) + sizeof(int)));//访问第三个变量 注意： char 占sizeof（int）4个字节--内存对齐
	int xz = *(int*)((int)&objb + sizeof(int) + sizeof(int) + sizeof(double));//访问第四个变量
	cout << x << endl;
	cout << y << endl;
	cout << z << endl;
	cout << xz << endl;
 
	cout << endl;
 
	B *pb = new B(22, 'D', 88.888,55);
	
	x = *(int*)(int)pb;
	y = *((char*)((int)pb + sizeof(int)));
	z = *((double*)((int)pb + sizeof(int) + sizeof(int)));//访问第三个变量 注意： char 占sizeof（int）4个字节--内存对齐
	xz = *(int*)((int)pb + sizeof(int) + sizeof(int) + sizeof(double));//访问第四个变量
	cout << x << endl;
	cout << y << endl;
	cout << z << endl;
	cout << xz << endl;
}
 
int main()
{
	cout << "===test01()===" << endl;
	test01();
	cout << endl;
	cout << "===test02()===" << endl;
	test02();
	
	cout << endl;
	system("pause");
	return EXIT_SUCCESS;
}
```
输出结果：
```cpp
===test01()===
10
@
30.5
 
40
A
60.8
 
===test02()===
11
C
99.999
66
 
22
D
88.888
55
```

### 虚继承
#### 多继承-菱形继承
多继承（Multiple Inheritance）是指从多个直接基类中产生派生类的能力，多继承的派生类继承了所有父类的成员。尽管概念上非常简单，但是多个基类的相互交织可能会带来错综复杂的设计问题，命名冲突就是不可回避的一个。

多继承时很容易产生命名冲突，即使我们很小心地将所有类中的成员变量和成员函数都命名为不同的名字，命名冲突依然有可能发生，比如典型的是菱形继承，如下图所示：
![菱形继承](04菱形继承1.png)
类 A 派生出类 B 和类 C，类 D 继承自类 B 和类 C，这个时候类 A 中的成员变量和成员函数继承到类 D 中变成了两份，一份来自 A-->B-->D 这条路径，另一份来自 A-->C-->D 这条路径。

在一个派生类中保留间接基类的多份同名成员，虽然可以在不同的成员变量中分别存放不同的数据，但大多数情况下这是多余的：因为保留多份成员变量不仅占用较多的存储空间，还容易产生命名冲突。假如类 A 有一个成员变量 a，那么在类 D 中直接访问 a 就会产生歧义，编译器不知道它究竟来自 A -->B-->D 这条路径，还是来自 A-->C-->D 这条路径。下面是菱形继承的具体实现：
```cpp
//间接基类A
class A{
protected:
    int m_a;
};
//直接基类B
class B: public A{
protected:
    int m_b;
};
//直接基类C
class C: public A{
protected:
    int m_c;
};
//派生类D
class D: public B, public C{
public:
    void seta(int a){ m_a = a; }  //命名冲突
    void setb(int b){ m_b = b; }  //正确
    void setc(int c){ m_c = c; }  //正确
    void setd(int d){ m_d = d; }  //正确
private:
    int m_d;
};
int main(){
    D d;
    return 0;
}
```
这段代码实现了上图所示的菱形继承，第 25 行代码试图直接访问成员变量 m_a，结果发生了错误，因为类 B 和类 C 中都有成员变量 m_a（从 A 类继承而来），编译器不知道选用哪一个，所以产生了歧义。

为了消除歧义，我们可以在 m_a 的前面指明它具体来自哪个类：
```cpp
void seta(int a){ B::m_a = a; }
```
这样表示使用 B 类的 m_a。当然也可以使用 C 类的：
```cpp
void seta(int a){ C::m_a = a; }
```
#### 虚继承（Virtual Inheritance）
为了解决多继承时的命名冲突和冗余数据问题，C++ 提出了虚继承，使得在派生类中只保留一份间接基类的成员。

在继承方式前面加上 virtual 关键字就是虚继承，请看下面的例子：
```cpp
//间接基类A
class A{
protected:
    int m_a;
};
//直接基类B
class B: virtual public A{  //虚继承
protected:
    int m_b;
};
//直接基类C
class C: virtual public A{  //虚继承
protected:
    int m_c;
};
//派生类D
class D: public B, public C{
public:
    void seta(int a){ m_a = a; }  //正确
    void setb(int b){ m_b = b; }  //正确
    void setc(int c){ m_c = c; }  //正确
    void setd(int d){ m_d = d; }  //正确
private:
    int m_d;
};
int main(){
    D d;
    return 0;
}
```
这段代码使用虚继承重新实现了上图所示的菱形继承，这样在派生类 D 中就只保留了一份成员变量 m_a，直接访问就不会再有歧义了。

虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类（Virtual Base Class），本例中的 A 就是一个虚基类。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。

现在让我们重新梳理一下本例的继承关系，如下图所示：
![使用虚继承解决菱形继承中的命名冲突问题](04使用虚继承解决菱形继承0.png)
观察这个新的继承体系，我们会发现虚继承的一个不太直观的特征：必须在虚派生的真实需求出现前就已经完成虚派生的操作。在上图中，当定义 D 类时才出现了对虚派生的需求，但是如果 B 类和 C 类不是从 A 类虚派生得到的，那么 D 类还是会保留 A 类的两份成员。

换个角度讲，虚派生只影响从指定了虚基类的派生类中进一步派生出来的类，它不会影响派生类本身。

在实际开发中，位于中间层次的基类将其继承声明为虚继承一般不会带来什么问题。通常情况下，使用虚继承的类层次是由一个人或者一个项目组一次性设计完成的。对于一个独立开发的类来说，很少需要基类中的某一个类是虚基类，况且新类的开发者也无法改变已经存在的类体系。

C++标准库中的 iostream 类就是一个虚继承的实际应用案例。iostream 从 istream 和 ostream 直接继承而来，而 istream 和 ostream 又都继承自一个共同的名为 base_ios 的类，是典型的菱形继承。此时 istream 和 ostream 必须采用虚继承，否则将导致 iostream 类中保留两份 base_ios 类的成员。
![图3：虚继承在C++标准库中的实际应用](04虚继承在C++标准库中的实际应用png.png)

#### 虚基类成员的可见性
因为在虚继承的最终派生类中只保留了一份虚基类的成员，所以该成员可以被直接访问，不会产生二义性。此外，如果虚基类的成员只被一条派生路径覆盖，那么仍然可以直接访问这个被覆盖的成员。但是如果该成员被两条或多条路径覆盖了，那就不能直接访问了，此时必须指明该成员属于哪个类。

以图2中的菱形继承为例，假设 A 定义了一个名为 x 的成员变量，当我们在 D 中直接访问 x 时，会有三种可能性：
如果 B 和 C 中都没有 x 的定义，那么 x 将被解析为 A 的成员，此时不存在二义性。
如果 B 或 C 其中的一个类定义了 x，也不会有二义性，派生类的 x 比虚基类的 x 优先级更高。
如果 B 和 C 中都定义了 x，那么直接访问 x 将产生二义性问题。

可以看到，使用多继承经常会出现二义性问题，必须十分小心。上面的例子是简单的，如果继承的层次再多一些，关系更复杂一些，程序员就很容易陷人迷魂阵，程序的编写、调试和维护工作都会变得更加困难，因此我不提倡在程序中使用多继承，只有在比较简单和不易出现二义性的情况或实在必要时才使用多继承，能用单一继承解决的问题就不要使用多继承。也正是由于这个原因，C++ 之后的很多面向对象的编程语言，例如 Java、C#、PHP 等，都不支持多继承。

#### C++虚继承时的构造函数
在虚继承中，虚基类是由最终的派生类初始化的，换句话说，最终派生类的构造函数必须要调用虚基类的构造函数。对最终的派生类来说，虚基类是间接基类，而不是直接基类。这跟普通继承不同，在普通继承中，派生类构造函数中只能调用直接基类的构造函数，不能调用间接基类的。
```cpp
#include <iostream>
using namespace std;
//虚基类A
class A{
public:
    A(int a);
protected:
    int m_a;
};
A::A(int a): m_a(a){ }
//直接派生类B
class B: virtual public A{  //B：虚继承A
public:
    B(int a, int b);
public:
    void display();
protected:
    int m_b;
};
B::B(int a, int b): A(a), m_b(b){ }
void B::display(){
    cout<<"m_a="<<m_a<<", m_b="<<m_b<<endl;
}
//直接派生类C
class C: virtual public A{  // B：虚继承A
public:
    C(int a, int c);
public:
    void display();
protected:
    int m_c;
};
C::C(int a, int c): A(a), m_c(c){ }
void C::display(){
    cout<<"m_a="<<m_a<<", m_c="<<m_c<<endl;
}
//间接派生类D
class D: public B, public C{    // D：公开继承B、C
public:
    D(int a, int b, int c, int d);
public:
    void display();
private:
    int m_d;
};
D::D(int a, int b, int c, int d): A(a), B(90, b), C(100, c), m_d(d){ }
void D::display(){
    cout<<"m_a="<<m_a<<", m_b="<<m_b<<", m_c="<<m_c<<", m_d="<<m_d<<endl;
}
int main(){
    B b(10, 20);
    b.display();
   
    C c(30, 40);
    c.display();
    D d(50, 60, 70, 80);
    d.display();
    system("pause");
    return 0;
}
运行结果：
m_a=10, m_b=20
m_a=30, m_c=40
m_a=50, m_b=60, m_c=70, m_d=80
```
请注意第 50 行代码，在最终派生类 D 的构造函数中，除了调用 B 和 C 的构造函数，还调用了 A 的构造函数，这说明 D 不但要负责初始化直接基类 B 和 C，还要负责初始化间接基类 A。而在以往的普通继承中，派生类的构造函数只负责初始化它的直接基类，再由直接基类的构造函数初始化间接基类，用户尝试调用间接基类的构造函数将导致错误。

现在采用了虚继承，虚基类 A 在最终派生类 D 中只保留了一份成员变量 m_a，如果由 B 和 C 初始化 m_a，那么 B 和 C 在调用 A 的构造函数时很有可能给出不同的实参，这个时候编译器就会犯迷糊，不知道使用哪个实参初始化 m_a。

为了避免出现这种矛盾的情况，C++ 干脆规定必须由最终的派生类 D 来初始化虚基类 A，直接派生类 B 和 C 对 A 的构造函数的调用是无效的。在第 50 行代码中，调用 B 的构造函数时试图将 m_a 初始化为 90，调用 C 的构造函数时试图将 m_a 初始化为 100，但是输出结果有力地证明了这些都是无效的，m_a 最终被初始化为 50，这正是在 D 中直接调用 A 的构造函数的结果。

另外需要关注的是构造函数的执行顺序。虚继承时构造函数的执行顺序与普通继承时不同：在最终派生类的构造函数调用列表中，不管各个构造函数出现的顺序如何，编译器总是先调用虚基类的构造函数，再按照出现的顺序调用其他的构造函数；而对于普通继承，就是按照构造函数出现的顺序依次调用的。

修改本例中第 50 行代码，改变构造函数出现的顺序：
```cpp
D::D(int a, int b, int c, int d): B(90, b), C(100, c), A(a), m_d(d){ }
```
虽然我们将 A() 放在了最后，但是编译器仍然会先调用 A()，然后再调用 B()、C()，因为 A() 是虚基类的构造函数，比其他构造函数优先级高。如果没有使用虚继承的话，那么编译器将按照出现的顺序依次调用 B()、C()、A()。

#### C++虚继承的内存模型
C++虚继承的内存模型是一个经典的问题，其具体实现依赖于编译器，可能会出现较大差异，但原理和最终的目的是大体相同的。本文将对g++中虚继承的内存模型进行详细解析。

##### 多继承存在的问题
++的多继承是指从多个直接基类中产生派生类的能力，多继承的派生类继承了所有父类的成员。从概念上来讲这是非常简单的，但是多个基类的相互交织可能会带来错综复杂的设计问题，命名冲突就是不可回避的一个，比如典型的是菱形继承，如图所示：
![菱形继承](04菱形继承2.png)
在图2-1中，类A派生出类B和类C，类D继承自类B和类C，这个时候类A中的成员变量和成员函数继承到类D中变成了两份，一份来自A–>B–>D这条路径，另一份来自A–>C–>D这条路径。
在一个派生类中保留间接基类的多份同名成员，虽然可以在不同的成员变量中分别存放不同的数据，但大多数情况下这是多余的，因为保留多份成员变量不仅占用较多的存储空间，还容易产生命名冲突。假如类A有一个成员变量a，那么在类D中直接访问a就会产生歧义，编译器不知道它究竟来自A–>B–>D这条路径，还是来自A–>C–>D这条路径。下面是菱形继承的代码实现：
```cpp
#include <iostream>
#include <stdint.h>

class A
{
public:
    long a;
};

class B: public A
{
public:
    long b;
};


class C: public A
{
public:
    long c;
};

class D: public B, public C
{
public:
    void seta(long v) { a = v; } // 命名冲突
    void setb(long v) { b = v; } // 正确
    void setc(long v) { c = v; } // 正确
    void setd(long v) { d = v; } // 正确

private:
    long d;
};

int main(int argc, char* argv[])
{
    D d;
}

```
这段代码就是图2-1所示的菱形继承的具体实现，可以看到在类D的seta()方法中，代码试图直接访问间接基类的成员变量a，结果发生了错误，因为类B和类C中都有成员变量a（都是从类A继承的），编译器不知道选用哪一个，所以产生了歧义。

为了消除歧义，我们可以在使用a时指明它具体来自哪个类，代码如下：
```cpp
void seta(long v) { B::a = v; }
/* 或 */
void seta(long v) { C::a = v; }
```

使用GDB查看变量d的内存布局，如图2-2所示：
![GDB查看内存](04菱形继承GDB内存.png)
于是我们可以画出变量d的内存布局，如图2-3所示：
![内存布局](04菱形继承GDB内存布局.png)

##### 虚继承在标准库中的使用
C++标准库中的iostream就是一个虚继承的典型案例。iostream是从istream和ostream直接继承而来的，而istream和ostream又都继承自一个名为ios的类，这个就是一个典型的菱形继承。此时istream和ostream必须采用虚继承，否则将导致iostream中保留两份ios的成员。

iostream相关的源代码如下（从gcc-2.95.3版本中摘录出来的，内容有所省略）：
```cpp
struct _ios_fields
{ // The data members of an ios.
    streambuf *_strbuf;
    ostream* _tie;
    int _width;
    __fmtflags _flags;
    _IO_wchar_t _fill;
    __iostate _state;
    __iostate _exceptions;
    int _precision;

    void *_arrays; /* Support for ios::iword and ios::pword. */
};

class ios : public _ios_fields
{...};

class istream : virtual public ios
{...};

class ostream : virtual public ios
{...};

class iostream : public istream, public ostream
{
public:
    iostream() { }
    iostream(streambuf* sb, ostream*tied=NULL);
};
```

##### 虚继承下派生类的内存布局解析
g++中是没有所谓的虚基类表的（据说vs是有单独一个虚基类表的），只有一个虚表，由于平时用的比较多的是虚函数，所以一般情况下都直接管它叫做虚函数表，在g++编译环境下这种叫法其实是不严谨的。测试程序如下：
```cpp
#include <iostream>
#include <stdint.h>

class A
{
public:
    long a;
};

class B: virtual public A
{
public:
    long b;
};

class C: virtual public A
{
public:
    long c;
};

class D: public B, public C
{
public:
    void seta(long v) { a = v; }
    void setb(long v) { b = v; }
    void setc(long v) { c = v; }
    void setd(long v) { d = v; }

private:
    long d;
};

int main(int argc, char* argv[])
{
    D d;
    d.seta(1);
    d.setb(2);
    d.setc(3);
    d.setd(4);
}
```
类D在当前编译器(GCC 4.8.5)下的内存布局如图5-1所示：
![类D内存布局](04类的内存布局.png)
从图5-1中可以看出这个表和之前这篇文章《一文读懂C++虚函数的内存模型》讲的虚函数表是差不多的，就多了一个vbase_offset而已。因为这里的类设计比较简单，没有把虚函数加进来，有虚函数的话_vptr.B或者_vptr.C下面的内存空间存储的就是指向对应虚函数的指针了（以下只讲_vptr.B的相关内容，_vptr.C同理就不赘述了）。

这里可以看到_vptr.B指向的是虚函数的起始地址（因为这里没有虚函数，所以下面紧接着就是_vptr.C的内容），而不是与它相关联的全部信息的起始地址，事实上从图5-1中可以看出_vptr.B - 3 ~ _vptr.B这个范围内的数据都是类B虚表的内容（不知道编译器为什么这么设计，这里也进行揣测了），这三个特殊的内存地址存储的内容解析如下：

1. _vptr.B - 1：这里存储的是typeinfo for D，里面的内容其实也是一个指针，指向的是类D的运行时信息，这些玩意都是为了支持RTTI的。RTTI的相关内容以后会讲，这里就先不多分析了。
2. _vptr.B - 2：这里存储的是offset_to_top，这个表示的是当前的虚表指针距离类开头的距离，可以看到对于_vptr.B来说这个值就是0，因为_vptr.B就存在于类D的起始位置，而对于_vptr.C来说这个值是-16，大家可以算一下_vptr.C与类D的起始位置确实是差两个地址也就是16个字节（64位系统），至于为什么是负数，这是因为堆内存是向下增长的，越往下地址数值越大。
>offset_to_top深度解析：在多继承中，由于不同基类的起点可能处于不同的位置，因此当需要将它们转化为实际类型时，this指针的偏移量也不相同。由于实际类型在编译时是未知的，这要求偏移量必须能够在运行时获取。实体offset_to_top表示的就是实际类型起始地址到当前这个形式类型起始地址的偏移量。在向上动态转换到实际类型时（即基类转派生类），让this指针加上这个偏移量即可得到实际类型的地址。需要注意的是，由于一个类型即可以被单继承，也可以被多继承，因此即使只有单继承，实体offset_to_top也会存在于每一个多态类型之中。
（这里要注意一点就是offset_to_top只存在于多态类型中，所以我们可以看到在第二小节那个例子中，根本就没有什么所谓的虚表之类的东西，它也就不支持RTTI，最简单的大家可以使用dynamic_cast去试试，会报错说该类型不具备多态性质的。那么问题来了，怎样才能以最简短的方式让它具备多态的性质呢？很简单，定义一个析构函数，用virtual修饰即可）
3. _vptr.B - 3：这里存储的是vbase_offset，这个表示的是当前虚表指针与其对应的虚基类的距离。从图中可以看出对于_vptr.B来说这个值是40，算一下刚好是_vptr.B与a的差距，_vptr.C同理。
>vbase_offset深度解析：以测试程序为例，对于类型为B的引用，在编译时，无法确定它的虚基类A它在内存中的偏移量。因此，需要在虚表中额外再提供一个实体，表明运行时它的基类所在的位置，这个实体称为vbase_offset，位于offset_to_top上方。
接下来我们通过GDB来验证一下前面讲的内容，先打印出变量d的内存信息，如图5-2所示：
![变量d的内存信息](04变量d的内存信息.png)
从图5-2中可以看到变量d的内容与前面分析的差不多，接下来我们来看一下这两个虚表的内容，如图5-3所示：
![两个虚表的内容](04两个虚表的内容.png)
从图5-3中可以看出前面的内存图是正确的，接下来就再看一下变量d自身的内存布局，如图5-4所示：
![变量d自身的内存布局](04变量d自身的内存布局.png)
图5-4显示出的结果和前面图5-1的完全一致，到这里调试就结束了，由调试结果可以知道图5-1的内存模型是正确的。
>这里要补充一点，就是对于虚继承下的类D，和第二节那个没有虚继承的相比，基类A的位置被移动到了类D的最末尾，不过不用担心，运行时可以靠vbase_offset找到它。

### 多态
#### 1.静态多态
包括函数重载和函数模板。静态多态是由编译器在编译期间完成的。
函数重载：重载函数的关键是函数参数列表。包括：函数的参数数目和类型，以及参数的排列顺序。
函数的返回值不作为函数重载的依据（只有返回值不同的两个函数不能发生重载）

#### 2.动态多态
动态多态是程序在运行时动态绑定函数实现多态。
派生类配合虚函数，由父类指针指向子类对象，实现运行时多态。

#### 3.虚函数与纯虚函数
- 子类的虚函数可以不被子类重写，但父类的纯虚函数必须被子类重写
- 含有纯虚函数的类叫抽象类，抽象类不能实例化对象，而含有虚函数不含有纯虚函数的类可以实例化对象

#### 4.构造函数、析构函数、虚函数
- 结论：C++中，构造函数不可以是虚函数，而析构函数可以且常常是虚函数。
- 首先，构造函数没必要时虚函数
在调用构造函数时还不能确定对象的真实类型（由于子类会调父类的构造函数）；并且构造函数的作用是提供初始化，在对象生命期仅仅运行一次，因此，构造函数没必要是虚函数
- 其次，构造函数也不能是虚函数
虚函数的调用是通过虚函数表来实现的。而虚函数表是由类的实例化对象的vptr指针去寻找的。也就是说一个类的虚函数表需要类对象去寻找。那么我们就必须先创建并初始化好一个对象实例，而类的构造函数就是用来创建初始化实例对象的，这就产生了矛盾：
要想实例化对象我们就必须知道虚函数表在哪，这样才能完成初始化，而虚函数表又必须由实例化好的对象的vptr指针才能找到
这两个变成了一种死锁的状态，因此，构造函数不可以是虚函数。
- 我们使用虚函数往往是用来实现多态的，而多态是由父类指针指向子类对象实现的，那么在析构的时候如果不重写父类的析构函数，那么只会调用父类的析构函数，而父类的析构函数只会释放父类空间，那么子类的一些空间就没办法释放，造成内存泄漏。
```c++
class Father {
public:
	Father() {
		cout << "父类构造函数被调用" << endl;
	}
	~Father() {
		cout << "父类析构函数被调用" << endl;
	}
};
class Son : public Father {
public:
	Son() {
		cout << "子类构造函数被调用" << endl;
	}

	~Son() {
		cout << "子类析构函数被调用" << endl;
	}
};
```
```c++
Father* fa = new Son();
delete fa;
输出：
父类构造函数被调用
子类构造函数被调用
父类析构函数被调用

若将父类的析构函数改成虚函数，输出：
父类构造函数被调用
子类构造函数被调用
子类析构函数被调用
父类析构函数被调用
```



























## 常见问题
### class 和 struct的区别

C++ 中保留了C语言的 struct 关键字，并且加以扩充。在C语言中，struct 只能包含成员变量，不能包含成员函数。而在C++中，struct 类似于 class，既可以包含成员变量，又可以包含成员函数。

- C++中的 struct 和 class 基本是通用的，唯有几个细节不同：
  - 使用 class 时，类中的成员默认都是 private 属性的；而使用 struct 时，结构体中的成员默认都是 public 属性的。
  - class 继承默认是 private 继承，而 struct 继承默认是 public 继承。
  - class 可以使用模板，而 struct 不能。
- C++ 没有抛弃C语言中的 struct 关键字，其意义就在于给C语言程序开发人员有一个归属感，并且能让C++编译器兼容以前用C语言开发出来的项目。
- 在编写C++代码时，我强烈建议使用 class 来定义类，而使用 struct 来定义结构体，这样做语义更加明确。

