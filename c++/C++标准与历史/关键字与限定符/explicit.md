# explicit
在C++中，explicit关键字是一个用于限制构造函数或类型转换运算符的特殊限定符，它的主要目的是控制编译器如何执行类型转换，从而增强代码的清晰度、减少类型转换错误，并提升程序的健壮性。

## 目的
explicit关键字的主要目的是禁止编译器执行从一个类型到另一个类型的隐式类型转换，尤其是在使用构造函数或类型转换运算符时。这有助于避免非预期的类型转换，这些转换可能导致逻辑错误或不符合程序员初衷的行为。

## 隐式转换
常见场景：
1. 数值类型提升：在涉及运算的不同数值类型中，较小的类型通常会被自动转换为较大的类型，以避免数据丢失。例如，在C++中，计算 int + double 时，int 类型的值会被提升为 double 类型。

2. 算术转换：进行算术运算时，不同类型会转换为同一类型。例如，整数与浮点数运算时，整数会被转换为浮点数。

3. 指针与布尔值转换：在很多语言中，空指针（如C++中的nullptr）在布尔上下文中被视为false，非空指针被视为true。

4. 数组与指针：在C/C++中，数组名在大多数情况下会被自动转换为指向其首元素的指针。

5. 类对象与基类对象：面向对象编程中，派生类对象可隐式转换为其基类类型的对象或指针/引用。

6. 类型构造与函数重载解析：编译器可能会根据函数参数或操作符重载的需要，隐式转换实参类型。

### C++11 隐式转换
C++11确实引入了对构造函数的改进，允许在某些条件下进行更灵活的隐式类型转换。具体来说，如果一个构造函数除了第一个参数之外的所有参数都有默认值，那么这个构造函数可以用于隐式类型转换。这意味着，即使构造函数有多个参数，只要从第一个之后的参数都可以通过默认值“省略”，这样的构造函数就可以在需要的场合被编译器用来执行隐式类型转换。
```cpp
class MyClass {
public:
    MyClass(int a, std::string s = "") : a_(a), s_(s) {} // 第二个参数有默认值

    // ... 其他成员
private:
    int a_;
    std::string s_;
};
```
在这个例子中，MyClass 的构造函数接受两个参数，其中第二个参数 s 有默认值。因此，这个构造函数可以用于从 int 类型到 MyClass 类型的隐式转换，例如：
```cpp
MyClass obj = 42; // 隐式转换，使用默认的字符串""
```
然而，值得注意的是，过度使用这种隐式转换可能导致代码的可读性和可维护性降低，因为它可能使类型转换发生得不那么明显。因此，在设计类时，应该谨慎考虑是否需要这样的隐式转换，并且C++提供了 explicit 关键字来显式禁止这种行为，确保构造函数只能显式调用。

## 防止构造函数的隐式转换
当一个类的构造函数只有一个参数时，这个构造函数可以被隐式调用来进行类型转换。例如，如果你有一个接受int参数的构造函数，编译器可能会在需要该类实例的地方自动将一个int值转换成该类的对象。通过将这样的构造函数声明为explicit，你可以阻止这种隐式转换，要求必须通过直接初始化或显式类型转换来创建对象。
```cpp
class Widget {
public:
    explicit Widget(int size) {
        // 构造函数实现
    }
};
 
void doSomething(Widget w) {
    // 函数实现
}
 
// 示例使用
Widget w(10);    // 直接初始化是允许的
// doSomething(10); // 错误：不能隐式转换int到Widget
doSomething(Widget(10)); // 正确：显式转换
```
在这个例子中，Widget的构造函数被标记为explicit，因此不能隐式地从int转换为Widget。

## 防止转换运算符的隐式转换
类可以通过定义**类型转换运算符**（如operator int()）来允许对象被隐式转换为另一种类型。标记这样的转换运算符为explicit，可以防止这种隐式转换，要求转换必须通过显式类型cast（如(int)myObject）来执行。
```cpp
class Boolean {
    bool value;
public:
    Boolean(bool value) : value(value) {}
    explicit operator bool() const {
        return value;
    }
};
 
// 示例使用
Boolean b(true);
bool val = b; // 错误：不能隐式转换Boolean到bool
bool val2 = static_cast<bool>(b); // 正确：显式转换
```
在这个例子中，Boolean类的转换运算符被标记为explicit，阻止了其隐式转换到bool。

## 使用场景
- 提高代码可读性：通过阻止隐式转换，explicit关键字强制程序员显式地表明转换的意图，提高代码的可读性和可维护性。
- 避免意外的行为：隐式转换有时会导致意料之外的行为，使用explicit可以避免这类问题。

```cpp
class Fraction {
    int numerator, denominator;
public:
    explicit Fraction(int n, int d = 1) : numerator(n), denominator(d) {}
    // ...
};
 
void processFraction(Fraction f) {
    // 函数实现
}
 
// 示例使用
Fraction f = Fraction(3, 4); // 正确：显式构造
```
在这个例子中，Fraction的构造函数被标记为explicit，避免了int到Fraction的隐式转换，使得转换意图更加明确。

总之，explicit关键字是C++中一个非常有用的特性，它能有效地避免因隐式类型转换导致的错误和不可预期的行为，提高代码的安全性和可维护性。

