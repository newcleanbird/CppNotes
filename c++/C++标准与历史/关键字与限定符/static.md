# static
static "静态" "静止的"，经过static修饰的变量，存储在内存的全局静态区。且被static修饰的变量只能在本模块的所有函数引用。

## 核心本质:
### 改变生命周期(存储区、):局部变量
1.局部变量->静态局部变量
自动存储(栈)->静态存储(静态存储区)

2.类成员变量->类静态成员变量
自动存储(栈)->静态存储(静态存储区)
作用域:和权限有关(public、protected、private)

### 改变作用域:全局变量
全局变量->静态全局变量(静态存储区)
全局作用域(外部连接性)->局部作用域

### 1.作用：
#### (1)隐藏：
- 所有未加static前缀的全局变量和函数都具有全局可见性，static修饰的全局变量和函数只能在被定义文件中可见。
#### (2)保持变量内容的持久:
- 存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。虽然这种用法不常见，但我还是举一个例子。
#### （3）static的第三个作用是默认初始化为0。
- 其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。比如初始化一个稀疏矩阵，我们可以一个一个地把所有元素都置0，然后把不是0的几个元素赋值。如果定义成静态的，就省去了一开始置0的操作。再比如要把一个字符数组当字符串来用，但又觉得每次在字符数组末尾加'\ 0'太麻烦。如果把字符串定义成静态的，就省去了这个麻烦，因为那里本来就是'\0'。

### 2.内存中的存储区域如下：
#### 1.堆区：
- 是由程序员手动申请（new）与释放（delete）的内存区域。从低地址向高地址申请；内存空间大、存储地址不连续，一般是链式的；速度较慢。
#### 2.栈区：
- 由编译器自动分配和释放，主要存储 函数的参数值、函数内部的变量的值、函数调用的空间。从高地址向低地址申请；容量有限；速度较快；存储地址连续，会溢出。
#### 3.代码区：
又叫文本段（.text）,存放着程序的机器代码，可执行指令就是存储在这里的，这里的代码是只读的。
#### 4.全局区（静态区）：
==全局变量==和==静态变量(static)==是存储在这里的。初始化的全局变量和静态变量在一块区域（.data），未初始化的全局变量和未初始化的静态变量在相邻的另一块区域(.bbs)。系统结束后由系统释放。
#### 5.常量区：
常量字符串放在这里，程序结束后，由系统进行释放。

## static修饰不同的对象
static分为"面向过程"static 和"面向对象"static:
- 面向过程的static主要包括"静态全局变量"、"静态局部变量"和"静态函数"
- 面向对象的static主要包括"静态成员变量"、"静态成员函数"

### 静态全局变量
#### 定义
- 全局变量前添加static关键字，则该变量称为"静态全局变量"。

#### 特点
- 自动初始化为0；
在全局数据中的变量如果没有显示的初始化会自动被程序==初始化为0==(这个特性非静态全局变量也有)，而在函数体内声明的变量如果不显示初始化则会使一个随机值；
- 整个文件是可见的；
静态全局变量在==声明它的整个文件中都是可见的==，而在==文件之外是不可见的==；
- ==全局数据区==分配内存；
静态全局变量在全局数据区分配内存；
- 其他文件中可以定义同名变量，不冲突。
其他文件中可以定义同名int型变量a，不会冲突；

#### 对比全局变量：
- 如果将static去掉，具有以下特点：
1. 全局变量默认是有外部连接性的,其作用域是整个工程,在一个文件内定义的全局变量可以通过包含其所在“头文件”或“显示调用extern关键字”修饰全局变量的变量名声明来引用；
2. 静态全局变量是显示调用static修饰的全局变量，其作用域只在声明此变量的文件中，其他文件即使使用extern关键字修饰其声明也不可使用；

### 静态局部变量
#### 定义
- 定义局部变量前添加static关键字，则该变量称为静态局部变量。
- 通常，在一个函数作用域内定义一个变量，每次运行到该函数时，系统会给局部变量分配内存。当函数结束时，该变量的内存会被系统回收至栈内存当中。
```c++
#include <iostream>
#include <stdio.h>

void Func()
{
    static int a = 5;
    printf("a = %d\n", a);
    a++;
}

int main()
{
    for (int i = 0; i < 5; i++)
    {
        Func();  //打印结果：5 6 7 8 9
    }

    system("pause");
    return 0;
}
```
#### 特点
1. 内存存放在程序的全局数据区中；
2. 静态局部变量在程序执行到该对象声明时，会被首次初始化。其后运行到该对象的声明时，不会再次初始化，这也是为什么上面程序测试函数每次输出的值都是递增的原因（只会被初始化一次）；
3. 如果静态局部变量没有被显式初始化，则其值会自动被系统初始化为0；
4. 局部静态变量不能被其作用域之外的其他模块调用，其调用范围仅限于声明该变量的函数作用域当中；

### 静态函数
#### 定义
函数返回类型前添加static关键字，则该变量称为静态函数。
```c++
#include <iostream>
#include <stdio.h>

static void Func()
{
    printf("This is a static function\n");
}

int main()
{
    Func(); 
    
    system("pause");
    return 0;
}
```
#### 特点
1. 作用域只在声明它的文件当中，不能被其他文件引用，其他文件可以定义同名的全局函数；
2. 其他文件想要调用本文件的静态函数，需要显示的调用extern关键字修饰其声明；

### 静态成员变量
#### 定义
被static修饰的成员变量称为静态成员变量。
- 静态成员变量是一种特殊的成员变量，它被关键字static修饰。
- 使用静态成员变量来实现==多个对象共享数据==的目标。
```c++
#include <iostream>
using namespace std;

class Student{
public:
    Student(char *name, int age, float score);
    void show();
private:
    static int m_total;  //静态成员变量
private:
    char *m_name;
    int m_age;
    float m_score;
};

//初始化静态成员变量
int Student::m_total = 0;

Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score){
    m_total++;  //操作静态成员变量
}
void Student::show(){
    cout<<m_name<<"的年龄是"<<m_age<<"，成绩是"<<m_score<<"（当前共有"<<m_total<<"名学生）"<<endl;
}

int main(){
    //创建匿名对象
    (new Student("小明", 15, 90)) -> show();
    (new Student("李磊", 16, 80)) -> show();
    (new Student("张华", 16, 99)) -> show();
    (new Student("王康", 14, 60)) -> show();

    return 0;
}
将 m_total 声明为静态成员变量，每次创建对象时，会调用构造函数使 m_total 的值加 1。
之所以使用匿名对象，是因为每次创建对象后只会使用它的 show() 函数，不再进行其他操作。不过使用匿名对象无法回收内存，会导致内存泄露，在中大型程序中不建议使用。
```
#### 访问
1. 静态成员变量要是公有:
   - static 成员变量既可以通过对象来访问，也可以通过类来访问。
   1. 通过类名访问:无需创建任何对象，直接使用``类名::静态成员变量``来访问。
   2. 通过类对象访问:``对象.静态成员``
   3. 通过类对象指针访问:```对象指针->静态成员`
   4. 通过匿名对象突破类域进行访问:
      1. 以上四种等价
   5. 在类的成员函数内部访问：直接访问``静态成员``

![匿名对象](../面向对象/匿名对象.md)
```cpp
Student::m_total = 10;  // 类名
stu.m_total = 20;       // 对象
pstu -> m_total = 20;   // 对象指针
Student().m_total = 20; // 匿名对象

```

2. 当静态成员变量为私有时：
    1. 通过``类名调用静态成员函数``进行访问
    2. 通过``类对象调用静态成员函数``进行访问
    3. 通过``类对象指针调用静态成员函数``进行访问
    4. 通过``匿名对象调用静态成员函数``进行访问
    5. 在类的成员函数内部访问：直接访问``静态成员``


#### 特点
1. 静态数据成员的服务对象并非是单个类实例化的对象，而是所有类实例化的对象(这点可以用于设计模式中的单例模式实现)；
2. static 成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是在（类外）初始化时分配。反过来说，没有在类外初始化的 static 成员变量不能使用；
3. 静态数据成员必须显式的初始化分配内存，在其包含类没有任何实例化之前已经有内存分配；
4. static 成员变量不占用对象的内存，而是在所有对象之外开辟内存，即使不创建对象也可以访问。
5. 静态数据成员内存存储在全局数据区，只随着进程的消亡而消亡；具体来说，static 成员变量和普通的 static 变量类似，都在内存分区中的全局数据区分配内存
6. 静态数据成员与其他成员一样，遵从public,protected,private的访问规则；

#### 优势
1. 静态数据成员==不进入程序全局命名空间==，不会与其他全局名称的同名同类型变量冲突；
2. 静态数据成员可以实现C++的==封装特性==，由于其遵守类的访问权限规则，所以相比全局变量更加灵活；

#### 几点说明
1. 一个类中可以有一个或多个静态成员变量，所有的对象都共享这些静态成员变量，都可以引用它。
2. static 成员变量和普通 static 变量一样，都在内存分区中的全局数据区分配内存，到程序结束时才释放。这就意味着，static 成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。而普通成员变量在对象创建时分配内存，在对象销毁时释放内存。
3. 静态成员变量必须初始化，而且只能在类体外进行。例如：
``int Student::m_total = 10;``
初始化时可以赋初值，也可以不赋值。如果不赋值，那么会被默认初始化为 0。全局数据区的变量都有默认的初始值 0，而动态数据区（堆区、栈区）变量的默认值是不确定的，一般认为是垃圾值。
4. 静态成员变量既可以通过对象名访问，也可以通过类名访问，但要遵循 private、protected 和 public 关键字的访问权限限制。当通过对象名访问时，对于不同的对象，访问的是同一份内存。

### 静态成员函数
在类中，static 除了可以声明静态成员变量，还可以声明静态(static)成员函数， 为了访问静态成员变量。

#### 定义
类的成员函数返回类型之前添加static，此成员函数为静态成员函数。

#### 特点
1. 普通成员函数可以访问所有成员（包括成员变量和成员函数），静态成员函数==只能访问静态成员==。
2. 编译器在编译一个普通成员函数时，会隐式地增加一个==形参 this==，并把==当前对象的地址==赋值给 this，所以==普通成员函数只能在创建对象后通过对象来调用==，因为它需要当前对象的地址。而==静态成员函数可以通过类来直接调用==，==编译器不会为它增加形参 this==，它不需要当前对象的地址，所以==不管有没有创建对象，都可以调用静态成员函数==。
3. 普通成员变量占用对象的内存，==静态成员函数没有 this 指针==，不知道指向哪个对象，无法访问对象的成员变量，也就是说==静态成员函数不能访问普通成员变量==，==只能访问静态成员变量==。
4. 普通成员函数必须通过对象才能调用，而静态成员函数没有 this 指针，无法在函数体内部访问某个对象，所以==不能调用普通成员函数==，==只能调用静态成员函数==。
5. 在没有实例化的类对象的条件下可以调用类的静态成员函数；
6. 静态成员函数中没有隐含的this指针，所以静态成员函数不可以操作类中的非静态成员
    （由于第二条可知，类的非静态成员是在类实例化后存在的，而类的成员函数可以在类没有实例化的时候调用，故不能操作类的非静态成员）；

#### 和普通成员函数的根本区别：
- 普通成员函数==有 this 指针==，可以访问类中的任意成员；
- 静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。

### 总结
1. 静态数据成员都是静态存储的，所以必须在main函数之前显示的对其进行初始化；
2. 可以在头文件中声明静态全局变量，该头文件被多个cpp文件包含后，包含该头文件的cpp文件实际上会各自拥有独立的同名变量；
3. 不能将静态成员函数定义为虚函数；
4. 静态成员函数没有this指针；
5. static缩短了子类对父类静态成员访问的时间，相对来说节省了内存空间；
6. 如果不想在子类中操作父类的静态成员，则可以在子类中定义一个同名的static成员。
- 这样既可覆盖父类中的静态成员，并且根据C++的多态性变量命名规则，这样做是安全的；
7. 静态成员声明在类中，操作在其外部，所以对其取地址操作就跟取普通成员的操作略有不同。
8. 静态变量地址是指向其数据类型的指针，函数地址则是一个类型为nonmember的函数指针；

## 经典问题
### static全局变量与普通的全局变量的区别？
1. 声明不同：
   - 全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。

2. 存储方式一样：
   - 全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。

3. 作用域不同：
这两者的区别在于非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。

4. 静态全局变量只能初始化一次
static全局变量只初使化一次，防止在其他文件单元中被引用;

### static局部变量和普通局部变量有什么区别？
1. 生命周期不同:
   - 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。 

2. 只能被初始化一次
   - static局部变量只被初始化一次，下一次依据上一次结果值(后面初始化无效，相当于直接跳过)
 　
### static函数与普通函数有什么区别？
##### 作用域不同
1. 作用域和链接性：
   - 普通函数默认具有外部链接性（extern），意味着它们可以在整个程序的不同源文件之间共享，只要通过适当的声明，其他文件中的代码就可以调用该函数。
   - 静态函数（static函数）具有内部链接性，限制了其作用域仅限于定义它的源文件中。这意味着在定义静态函数的文件之外，其他源文件中的代码无法看到或调用该函数，即使有相同签名的函数声明。

2. 生命周期：
   - 普通函数作为程序的一部分，其生命周期与程序相同，从程序开始运行时存在，直到程序结束。
   - 静态函数虽然在内存中同样存在并持续到程序结束，但强调的是其作用域限制，而非生命周期上的差异。

3. 存储方式：
   - 这一点描述可能有些混淆，因为通常讨论静态函数时关注的是其作用域和链接性，而非存储方式。不过，理论上，静态函数（作为代码）与普通函数一样，都是存储在程序的代码段中，与静态数据存储在静态存储区不是一回事。

4. 调用和优化：
   - 静态函数由于其作用域限制，编译器更容易对其进行内联优化，尤其是在单个编译单元内部，因为编译器能确切知道函数的所有调用点。
   - 普通函数由于可能被多个源文件调用，其调用关系和优化策略可能更为复杂。

5. 使用场景：
   - 普通函数适合那些需要在多个源文件间共享功能的场景。
   - 静态函数适用于实现文件级私有函数，即只在某个特定的源文件内部使用的辅助函数，有助于封装和减少命名冲突。
