# 左值和右值，左值引用和右值引用
## 左值（Lvalue）
- 定义：左值是指向内存位置的表达式，该位置可以被多次读写。简而言之，左值是有名字的持久对象，可以出现在赋值运算符的左侧。例如，变量名、解引用的指针或引用都是左值。
- 通俗理解：左值是指具有对应的可由用户访问的存储单元，并且能由用户改变其值的量。如一个变量就是一个左值，因为它对应着一个存储单元，并可由编程者通过变量名访问和改变其值。
- 左值(Lvalue) →→ Location
- 表示内存中可以寻址，可以给它赋值(const类型的变量例外)
- 特点：可寻址，可修改（除非是const或volatile修饰的）。
- 例子：int x; 中的 x，或者 ptr->value（假设ptr是一个有效指针）。

## 右值（Rvalue）
- 定义：右值是临时的、通常不可修改的表达式，通常用于表示数据的流动方向。右值要么是没有名字的对象（如字面量、临时对象），要么是将要被销毁的对象（如函数返回的局部变量）。
- 分类：
    - 纯右值（prvalue）：最典型的临时对象，非引用返回的临时变量( int func(void))、运算表达式产生的临时变量(b+c)、原始字面量(2)、lambda表达式等。
    - 将亡值（xvalue）：表示即将“消亡”的对象，通常由std::move操作产生，用于转移资源所有权。将要被移动的对象、T&&函数返回值、std::move返回值和转换为T&&的类型的转换函数的返回值。
- 特点：不可寻址，通常不可修改，生命周期短暂。
- 例子：42，std::string("Hello")，或 std::move(someString)。

### 纯右值（prvalue）
- 定义：纯右值是没有具体存储位置的临时对象，它们通常是新创建的对象或是计算的结果。纯右值不关联到任何持久存储上，因此它们既不能被取地址也不能被修改。
- 例子：字面量（如42、"Hello"）、大多数临时对象（如函数返回的非引用类型对象）、以及通过类型转换产生的临时对象。
- 用途：常用于初始化新对象或作为非引用参数传递给函数。在C++17之后，某些情况下纯右值也可以直接初始化引用，但这是特例。

### 将亡值（xvalue）
- 定义：将亡值是表达式的结果表示一个对象的资源即将被转移（通常是移动）给另一个对象，表明这个对象即将“消亡”。它是一个可以被移动的对象的“占位符”。
- 例子：通过std::move函数转换的左值或右值引用表达式，或者某些类型的重载了&&操作符的对象的表达式。
- 用途：将亡值主要用于实现高效的资源移动操作，避免不必要的深拷贝。当一个对象不再需要时，其资源可以被“移动”到另一个对象中，而不是复制，这样可以大大提高效率，特别是在处理大型对象或容器时。

### 纯右值和将亡值区别与联系
- 本质差异：纯右值不涉及任何已有对象的资源转移，而将亡值则明确表示资源即将被转移。
- 共同点：两者都是右值，意味着它们都可以绑定到右值引用上，且通常用于非保留的、一次性的操作。
- 应用上的区别：在实现移动语义时，纯右值可能直接用于初始化或移动操作，而将亡值更强调对象资源的主动“放弃”，常用于优化资源管理。


## 左值和右值
通俗的讲，左值就是能够出现在赋值符号左面的东西，而右值就是那些可以出现在赋值符号右面的东西， 比如 int a = b + c;，a 就是一个左值，可以对a取地址，而b+c 就是一个右值，对表达式b+c 取地址会报错。

一个典型的例子:
**a++**： 先使用a的值，再给a加1，作为**右值**
```cpp
// a++的实现
int temp = a;
a = a + 1;
return temp;
```
**++a**： 先加再用，作为**左值**
```cpp
a = a + 1;
return a;
```
在C++中，临时对象不能作为左值，但是可以作为常量引用，const &。

C++ 11中的std::move可将左值引用转化成右值引用。

C++11中右值又由两个概念组成：将亡值和纯右值。

## 左值引用与右值引用
- 左值引用（T&）：绑定到左值，延长左值的生命周期，但不改变其可修改性。常规的引用一般都是左值引用。
- 右值引用（T&&）：设计用于绑定到右值，特别适用于转移资源的所有权（移动语义），如移动构造函数和移动赋值操作。

```cpp
#include <iostream>
#include <vector>
using namespace std;
int main()
{
    int var = 42;
    int &l_var = var;
    int &&r_var = var; // 错误：不能将右值引用绑定到左值上

    int &&r_var2 = var + 40; // 正确：将 r_var2 绑定到求和结果上
    return 0;
}
```
引用本身不拥有所绑定对象的内存，只是该对象的一个别名，左值引用就是有名变量的别名，右值引用是不具名变量的别名。因此**无论左值引用还是右值引用都必须立即进行初始化**。

通过右值引用，这个将亡的右值又“重获新生”，它的生命周期与右值引用类型变量的生命周期一样，只要这个右值引用类型的变量还活着，那么这个右值临时量就会一直活着，这是一重要特性，可利用这一点会一些性能优化，避免临时对象的拷贝构造和析构。

左值引用包括常量左值引用和非常量左值引用。非常量左值引用只能接受左值，不能接受右值；常量左值引用是一个“万能”的引用类型，可以接受左值（常量左值、非常量左值）、右值。不过常量左值所引用的右值在它的“余生”中只能是只读的。
```cpp
int &a = 2;       // 非常量左值引用 绑定到 右值，编译失败
 
int b = 2;        // b 是非常量左值
const int &c = b; // 常量左值引用 绑定到 非常量左值，编译通过
 
const int d = 2;  // d 是常量左值
const int &e = d; // 常量左值引用 绑定到 常量左值，编译通过
const int &f =2;  // 常量左值引用 绑定到 右值，编译通过
```
右值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值。比如：
```cpp
int a;
int &&r1 = a;             // 编译失败
int &&r2 = std::move(a);  // 编译通过
```

简单总结：
- 左值引用, 即&i, 是一种对象类型的引用; 右值引用, 即&&i, 是一种对象值的引用;
- move() 函数可以把左值引用, 转换为右值引用;
- 左值引用是固定的引用, 右值引用是易变的引用, 只能引用字面值(literals)或临时对象(temporary object);
- 右值引用主要应用在移动构造器(move constructor) 和移动-赋值操作符(move-assignment operator)上面;

```cpp
#include <iostream>  
#include <utility>  
  
int main (void) {  
    int i = 42;  
    int &lr = i;  
    int &&rr = i*42;  
    const int &lr1 = i*42;  
    int &&rr1 = 42;  
    int &&rr2 = std::move(lr);  
    std::cout << "i = " << i << std::endl;  
    std::cout << "lr = " << lr << std::endl;  
    std::cout << "rr = " << rr << std::endl;  
    std::cout << "lr1 = " << lr1  <<std::endl;  
    std::cout << "rr1  = " << rr1  << std::endl;  
    std::cout << "rr2  = " << rr2  << std::endl;  
}  
```

### 实际应用
- 完美转发：利用std::forward，可以准确地传递参数，无论是左值还是右值，到另一个函数，这对于模板函数和通用编程非常重要。
- 移动语义：通过右值引用和移动构造函数/赋值操作，可以高效地重新分配资源，避免不必要的复制，提高性能。

## 标准库 move() 函数
std::move是C++标准库中的一个 utility 函数，位于<utility>头文件中。它的主要作用是将一个左值（即便是一个非临时对象）转换为右值引用，从而暗示编译器这个对象可以被“移动”而不是被复制。这在处理大型对象或者资源拥有对象时特别有用，因为它允许实现更高效的资源转移，避免不必要的深拷贝操作。
[move函数与移动语义](move函数与移动语义.md)





