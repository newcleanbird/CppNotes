# 内存泄露

## 什么是内存泄漏

内存泄漏：由于疏忽或错误导致的程序未能释放已经不再使用的内存。简单地说就是申请了一块内存空间，使用完毕后没有释放掉。

- 并非指内存从物理上消失，而是指程序在运行过程中，由于疏忽或错误而失去了对该内存的控制，从而造成了内存的浪费。
- 常指堆内存泄漏，因为堆是动态分配的，而且是用户来控制的，如果使用不当，会产生内存泄漏。
- 使用 malloc、calloc、realloc、new 等分配内存时，使用完后要调用相应的 free 或 delete释放内存，否则这块内存就会造成内存泄漏。
指针重新赋值

## 常见的内存泄露场景

（1）new和malloc申请资源使用后，没有用delete和free释放；
（2）子类继承父类时，父类析构函数不是虚函数。
（3）Windows句柄资源使用后没有释放。

举例：

```cpp
char *p = (char *)malloc(10);
char *p1 = (char *)malloc(10);
p = np;
```

开始时，指针 p 和 p1 分别指向一块内存空间，但指针 p 被重新赋值，导致 p 初始时指向的那块内存空间无法找到，从而发生了内存泄漏。

## 怎么防止内存泄漏？内存泄漏检测工具的原理？

防止内存泄漏的方法：

1. 良好的编码习惯，使用了内存分配的函数，一旦使用完毕,要记得使用其相应的函数释放掉。
2. 内部封装：将内存的分配和释放封装到类中，在构造的时候申请内存，析构的时候释放内存。（说明：但这样做并不是最佳的做法，在类的对象复制时，程序会出现同一块内存空间释放两次的情况）
3. 智能指针：智能指针是 C++ 中已经对内存泄漏封装好了一个工具，可以直接拿来使用，将在下一个问题中对智能指针进行详细的解释。
4. 将分配的内存的指针以链表的形式自行管理，使用完毕之后从链表中删除，程序结束时可检查改链表。
5. 一些常见的工具插件，如ccmalloc、Dmalloc、Leaky、Valgrind等等。
    - 使用VLD工具(Visual Leak Detector)

### VS下内存泄漏的检测方法（CRT）

检查方法：
在main函数最后面一行，加上一句_CrtDumpMemoryLeaks()。调试程序，自然关闭程序让其退出（不要定制调试），查看输出
在debug模式下以F5运行：

```cpp
#define CRTDBG_MAP_ALLOC  
#include <stdlib.h>  
#include <crtdbg.h>  
//在入口函数中包含 _CrtDumpMemoryLeaks();  
//即可检测到内存泄露
 
//以如下测试函数为例：
int main(){
    char* pChars = new char[10];
    CrtDumpMemoryLeaks();
    return 0;
}
```
